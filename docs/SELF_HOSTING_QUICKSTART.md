# Self-Hosting Quick Start Guide

Want to see EigenScript compile itself? This 5-minute guide will get you started.

## Prerequisites

```bash
# Install EigenScript with compiler support
pip install -e .[compiler]

# Install LLVM tools (Ubuntu/Debian)
sudo apt-get install llvm gcc

# Or on macOS
brew install llvm gcc
```

## Quick Test: Run the Bootstrap Script

The easiest way to test self-hosting is to run the automated bootstrap script:

```bash
# From the EigenScript repository root
bash scripts/bootstrap_test.sh
```

### What This Does

The script performs a 4-stage test:

1. **Stage 0 â†’ Stage 1**:
   - Uses the Python reference compiler to compile the self-hosted compiler
   - Creates `eigensc` executable (Stage 1 compiler)

2. **Stage 1 Test**:
   - Uses Stage 1 to compile a simple program
   - Verifies it produces valid LLVM IR

3. **Stage 1 â†’ Stage 2 (Bootstrap)**:
   - Stage 1 compiles itself to create Stage 2 compiler (`eigensc2`)
   - Validates the generated LLVM IR

4. **Bootstrap Verification**:
   - Compares Stage 1 and Stage 2 output on a test program
   - Confirms they produce identical results

### Expected Output

```
========================================
EigenScript Bootstrap Test
========================================

Step 1: Compile self-hosted compiler with reference compiler
------------------------------------------------------------
  Compiling lexer.eigs...
  Compiling parser.eigs...
  Compiling semantic.eigs...
  Compiling codegen.eigs...
  Compiling main.eigs...
  SUCCESS: Stage 1 compiler created (eigensc)

Step 2: Test stage 1 compiler with simple program
-------------------------------------------------
  SUCCESS: Stage 1 compiler produced valid LLVM IR

Step 3: Stage 1 compiler compiles itself (bootstrap)
----------------------------------------------------
  SUCCESS: Stage 1 compiler produced LLVM IR for itself!
  Functions defined: 12
  SUCCESS: Stage 2 LLVM IR is valid!
  SUCCESS: Stage 2 compiler created (eigensc2)!

Step 4: Compare stage 1 and stage 2 output
-----------------------------------------
  BOOTSTRAP SUCCESS: Stage 1 and Stage 2 produce identical output!

========================================
Bootstrap Test Complete
========================================
```

## Manual Step-by-Step

Want to do it manually? Here's the minimal process:

### 1. Compile the Self-Hosted Compiler

```bash
# Create a build directory
mkdir -p build/selfhost && cd build/selfhost

# Compile each module
eigenscript-compile ../../src/eigenscript/compiler/selfhost/lexer.eigs \
    -o lexer.ll -O0 --lib
eigenscript-compile ../../src/eigenscript/compiler/selfhost/parser.eigs \
    -o parser.ll -O0 --lib
eigenscript-compile ../../src/eigenscript/compiler/selfhost/semantic.eigs \
    -o semantic.ll -O0 --lib
eigenscript-compile ../../src/eigenscript/compiler/selfhost/codegen.eigs \
    -o codegen.ll -O0 --lib
eigenscript-compile ../../src/eigenscript/compiler/selfhost/main.eigs \
    -o main.ll -O0

# Compile the runtime
gcc -c ../../src/eigenscript/compiler/runtime/eigenvalue.c \
    -o eigenvalue.o -O2

# Assemble and link
for m in lexer parser semantic codegen main; do
    llvm-as $m.ll -o $m.bc
    llc $m.bc -o $m.s -O2
    gcc -c $m.s -o $m.o
done

gcc *.o -o eigensc -lm
```

You now have `eigensc` - the self-hosted compiler!

### 2. Test It

Create a simple EigenScript program:

```bash
cat > hello.eigs << 'EOF'
x is 42
print of x
EOF
```

Compile it with your self-hosted compiler:

```bash
./eigensc hello.eigs > hello.ll
```

Check that it generated LLVM IR:

```bash
head -20 hello.ll
```

You should see LLVM IR output starting with:
```llvm
; EigenScript Compiled Module
; Generated by self-hosting compiler

target triple = "x86_64-pc-linux-gnu"
...
```

## What You've Accomplished

ğŸ‰ Congratulations! You've just witnessed **full bootstrap** - one of the most significant milestones in programming language development:

1. **Compiled a compiler** written in EigenScript using the Python reference compiler
2. **Used that compiler (Stage 1)** to compile itself, creating Stage 2
3. **Verified identical output** - Stage 1 and Stage 2 produce the same results
4. **Achieved true self-hosting** - the language can fully compile its own compiler

## Current Status

âœ… **Bootstrap Achieved**:
- Stage 1 compiler successfully compiles itself to create Stage 2
- Stage 1 and Stage 2 produce **identical output**
- All 5 compiler modules (~5700 lines) compile, link, and run correctly
- Full LLVM IR generation pipeline works

âœ… **What Works**:
- Lexer, parser, semantic analysis, and code generation
- Cross-module function calls and external variable access
- List operations, string handling, and control flow
- Runtime library integration

## Next Steps

### Learn More

- Read the [Complete Self-Hosting Guide](./COMPILER_SELF_HOSTING.md) for architecture details
- Check out the [Meta-Circular Evaluator](./meta_circular_evaluator.md) (interpreter self-hosting)
- Browse the self-hosted compiler source: `src/eigenscript/compiler/selfhost/`

### Try More Examples

```bash
# More test programs
cd examples/compiler/

# Simple arithmetic
cat > test.eigs << 'EOF'
a is 10
b is 20
sum is a + b
print of sum
EOF

# Compile with Stage 1
../../build/selfhost/eigensc test.eigs > test.ll

# Check the output
head -50 test.ll
```

### Help Improve It

With bootstrap achieved, there's still room for improvement:

1. **Testing**: Try compiling more complex programs and report any issues
2. **Optimization**: Help improve compilation speed or generated code quality
3. **Features**: Add support for additional EigenScript language features
4. **Documentation**: Share your experiences and help improve these guides

See [CONTRIBUTING.md](../CONTRIBUTING.md) for contribution guidelines.

## Troubleshooting

### "eigenscript-compile not found"

```bash
# Make sure you installed with compiler support
pip install -e .[compiler]

# Check if it's in your PATH
which eigenscript-compile
```

### "llvm-as not found"

```bash
# Ubuntu/Debian
sudo apt-get update
sudo apt-get install llvm

# macOS
brew install llvm
export PATH="/usr/local/opt/llvm/bin:$PATH"
```

### Compilation Takes Forever

This is normal! Compiling 5700+ lines of EigenScript takes time. The reference compiler is not optimized for speed, prioritizing correctness instead.

- lexer.eigs: ~10-15 seconds
- parser.eigs: ~20-30 seconds
- semantic.eigs: ~10-15 seconds
- codegen.eigs: ~30-45 seconds
- main.eigs: ~5-10 seconds

**Total**: About 1-2 minutes on a modern system.

### "Parse error" When Running Stage 1

If you encounter a parse error, ensure your source file follows EigenScript syntax:
- Proper indentation (4 spaces recommended)
- No trailing whitespace issues
- Correct keyword usage

For complex programs, compare with examples in `examples/` directory.

## Understanding the Bootstrap Process

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stage 0: Python Reference Compiler          â”‚
â”‚ (Production, always works)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ compiles
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stage 1: Self-Hosted Compiler (eigensc)     â”‚
â”‚ (EigenScript compiler written in EigenScript)â”‚
â”‚ âœ… Compiles simple and complex programs      â”‚
â”‚ âœ… Generates valid LLVM IR                   â”‚
â”‚ âœ… Can compile itself                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ compiles itself
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stage 2: Second-Generation Compiler         â”‚
â”‚ (eigensc2 - Full Bootstrap Achieved!)        â”‚
â”‚ âœ… Created by Stage 1 compiling itself       â”‚
â”‚ âœ… Produces identical output to Stage 1      â”‚
â”‚ âœ… Bootstrap verification passed             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Current Status**: Full bootstrap achieved! Stage 1 successfully compiles itself to create Stage 2, and both produce identical output.

## Key Files

```
src/eigenscript/compiler/selfhost/
â”œâ”€â”€ lexer.eigs        # Tokenization (~700 lines)
â”œâ”€â”€ parser.eigs       # AST building (~1800 lines)
â”œâ”€â”€ semantic.eigs     # Variable scoping (~600 lines)
â”œâ”€â”€ codegen.eigs      # LLVM IR generation (~2300 lines)
â””â”€â”€ main.eigs         # Pipeline orchestration (~320 lines)

scripts/
â””â”€â”€ bootstrap_test.sh # Automated testing script

docs/
â”œâ”€â”€ COMPILER_SELF_HOSTING.md      # Complete guide
â””â”€â”€ SELF_HOSTING_QUICKSTART.md    # This document (you are here)
```

## FAQ

### Is this the same as the meta-circular evaluator?

No! EigenScript has **two types** of self-hosting:

1. **Meta-Circular Evaluator** (examples/eval.eigs)
   - An interpreter written in EigenScript
   - Can evaluate itself
   - âœ… Fully working

2. **Self-Hosted Compiler** (src/eigenscript/compiler/selfhost/)
   - A compiler written in EigenScript
   - Generates LLVM IR
   - âš ï¸ Partially working (this guide)

### Why is the compiler in EigenScript when the reference is in Python?

**Education & Validation**: Writing a compiler in EigenScript proves the language is mature and capable.

**Practical Uses**:
- Test the language with real-world complexity
- Find bugs and limitations
- Demonstrate language capabilities
- Foundation for future pure EigenScript toolchain

The Python compiler remains the primary, production-ready compiler.

### Can I use the self-hosted compiler for real projects?

The self-hosted compiler is now functional and passes bootstrap verification. However, for production use, the Python reference compiler (`eigenscript-compile`) is still recommended as it has more thorough testing and error handling. The self-hosted compiler is excellent for learning and experimentation.

### How big is the self-hosted compiler?

- **Total Lines**: ~5700 lines of EigenScript
- **Generated LLVM IR**: ~27000 lines
- **Runtime Library**: ~1700 lines of C
- **Total Project**: ~34000 lines

For comparison:
- TinyCC (a minimal C compiler): ~30000 lines of C
- Go compiler (go 1.0): ~100000 lines of Go
- Rust compiler (rustc): ~500000+ lines of Rust

## Success!

If you got this far and saw the bootstrap succeed, you've witnessed something remarkable: **a programming language that can fully compile its own compiler, with Stage 1 and Stage 2 producing identical output**.

This is one of the most significant milestones in programming language development. Many languages never achieve full bootstrap - EigenScript has!

ğŸš€ **Next**: Try reading through the [complete guide](./COMPILER_SELF_HOSTING.md) to understand how it all works internally.

---

**Questions?** Open an issue on GitHub or check the [documentation](./COMPILER_SELF_HOSTING.md).

**Want to help?** See [CONTRIBUTING.md](../CONTRIBUTING.md) to get involved!
