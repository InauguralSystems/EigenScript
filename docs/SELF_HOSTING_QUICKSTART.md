# Self-Hosting Quick Start Guide

Want to see EigenScript compile itself? This 5-minute guide will get you started.

## Prerequisites

```bash
# Install EigenScript with compiler support
pip install -e .[compiler]

# Install LLVM tools (Ubuntu/Debian)
sudo apt-get install llvm gcc

# Or on macOS
brew install llvm gcc
```

## Quick Test: Run the Bootstrap Script

The easiest way to test self-hosting is to run the automated bootstrap script:

```bash
# From the EigenScript repository root
bash scripts/bootstrap_test.sh
```

### What This Does

The script performs a 3-stage test:

1. **Stage 0 â†’ Stage 1**: 
   - Uses the Python reference compiler to compile the self-hosted compiler
   - Creates `eigensc` executable (Stage 1 compiler)
   
2. **Stage 1 Test**:
   - Uses Stage 1 to compile a simple program
   - Verifies it produces valid LLVM IR
   
3. **Bootstrap Attempt**:
   - Tries to have Stage 1 compile itself
   - Currently fails due to parser limitations (but shows progress!)

### Expected Output

```
========================================
EigenScript Bootstrap Test
========================================

Step 1: Compile self-hosted compiler with reference compiler
------------------------------------------------------------
  Compiling lexer.eigs...
  âœ“ Compilation successful!
  Compiling parser.eigs...
  âœ“ Compilation successful!
  ... (more modules) ...
  SUCCESS: Stage 1 compiler created (eigensc)

Step 2: Test stage 1 compiler with simple program
-------------------------------------------------
  SUCCESS: Stage 1 compiler produced valid LLVM IR

Step 3: Stage 1 compiler compiles itself (bootstrap)
----------------------------------------------------
  Parse error at line: 180
  (Known limitation: blank lines in function bodies)
```

## Manual Step-by-Step

Want to do it manually? Here's the minimal process:

### 1. Compile the Self-Hosted Compiler

```bash
# Create a build directory
mkdir -p build/selfhost && cd build/selfhost

# Compile each module
eigenscript-compile ../../src/eigenscript/compiler/selfhost/lexer.eigs \
    -o lexer.ll -O0 --lib
eigenscript-compile ../../src/eigenscript/compiler/selfhost/parser.eigs \
    -o parser.ll -O0 --lib
eigenscript-compile ../../src/eigenscript/compiler/selfhost/semantic.eigs \
    -o semantic.ll -O0 --lib
eigenscript-compile ../../src/eigenscript/compiler/selfhost/codegen.eigs \
    -o codegen.ll -O0 --lib
eigenscript-compile ../../src/eigenscript/compiler/selfhost/main.eigs \
    -o main.ll -O0

# Compile the runtime
gcc -c ../../src/eigenscript/compiler/runtime/eigenvalue.c \
    -o eigenvalue.o -O2

# Assemble and link
for m in lexer parser semantic codegen main; do
    llvm-as $m.ll -o $m.bc
    llc $m.bc -o $m.s -O2
    gcc -c $m.s -o $m.o
done

gcc *.o -o eigensc -lm
```

You now have `eigensc` - the self-hosted compiler!

### 2. Test It

Create a simple EigenScript program:

```bash
cat > hello.eigs << 'EOF'
x is 42
print of x
EOF
```

Compile it with your self-hosted compiler:

```bash
./eigensc hello.eigs > hello.ll
```

Check that it generated LLVM IR:

```bash
head -20 hello.ll
```

You should see LLVM IR output starting with:
```llvm
; EigenScript Compiled Module
; Generated by self-hosting compiler

target triple = "x86_64-pc-linux-gnu"
...
```

## What You've Accomplished

ğŸ‰ Congratulations! You've just:

1. **Compiled a compiler** written in EigenScript
2. **Used that compiler** to compile another program
3. **Demonstrated self-hosting** - the language compiling its own tools

## Current Limitations

âš ï¸ **Known Issues**:
- Stage 1 compiler has runtime bugs (produces incorrect output values)
- Parser cannot handle blank lines inside function bodies
- Stage 1 cannot yet compile itself (full bootstrap not achieved)

âœ… **What Works**:
- All modules compile successfully
- Stage 1 generates valid LLVM IR
- All 4 compiler modules (5700+ lines) compile and link

## Next Steps

### Learn More

- Read the [Complete Self-Hosting Guide](./COMPILER_SELF_HOSTING.md) for architecture details
- Check out the [Meta-Circular Evaluator](./meta_circular_evaluator.md) (interpreter self-hosting)
- Browse the self-hosted compiler source: `src/eigenscript/compiler/selfhost/`

### Try More Examples

```bash
# More test programs
cd examples/compiler/

# Simple arithmetic
cat > test.eigs << 'EOF'
a is 10
b is 20
sum is a + b
print of sum
EOF

# Compile with Stage 1
../../build/selfhost/eigensc test.eigs > test.ll

# Check the output
head -50 test.ll
```

### Help Improve It

The self-hosted compiler needs work to achieve full bootstrap. You can help by:

1. **Debugging Runtime Issues**: Why does print output incorrect values?
2. **Enhancing the Parser**: Add support for blank lines in function bodies
3. **Testing**: Try compiling more complex programs
4. **Documentation**: Share your findings and experiences

See [CONTRIBUTING.md](../CONTRIBUTING.md) for contribution guidelines.

## Troubleshooting

### "eigenscript-compile not found"

```bash
# Make sure you installed with compiler support
pip install -e .[compiler]

# Check if it's in your PATH
which eigenscript-compile
```

### "llvm-as not found"

```bash
# Ubuntu/Debian
sudo apt-get update
sudo apt-get install llvm

# macOS
brew install llvm
export PATH="/usr/local/opt/llvm/bin:$PATH"
```

### Compilation Takes Forever

This is normal! Compiling 5700+ lines of EigenScript takes time. The reference compiler is not optimized for speed, prioritizing correctness instead.

- lexer.eigs: ~10-15 seconds
- parser.eigs: ~20-30 seconds
- semantic.eigs: ~10-15 seconds
- codegen.eigs: ~30-45 seconds
- main.eigs: ~5-10 seconds

**Total**: About 1-2 minutes on a modern system.

### "Parse error" When Running Stage 1

The Stage 1 compiler's parser has a limitation with blank lines inside function bodies. The reference compiler handles this fine, but Stage 1 doesn't yet.

**Workaround**: Remove blank lines from your source file:

```bash
# Original (won't work with Stage 1)
cat > test.eigs << 'EOF'
define foo as:
    x is 10
    
    y is 20
    return x + y
EOF

# Fixed version (works with Stage 1)
cat > test.eigs << 'EOF'
define foo as:
    x is 10
    y is 20
    return x + y
EOF
```

## Understanding the Bootstrap Process

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stage 0: Python Reference Compiler          â”‚
â”‚ (Production, always works)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ compiles
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stage 1: Self-Hosted Compiler (eigensc)     â”‚
â”‚ (EigenScript compiler written in EigenScript)â”‚
â”‚ âœ… Can compile simple programs               â”‚
â”‚ âš ï¸  Has some runtime bugs                    â”‚
â”‚ âŒ Cannot yet compile itself                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ should compile (future)
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stage 2: Second-Generation Compiler         â”‚
â”‚ (Full Bootstrap Achievement)                 â”‚
â”‚ ğŸ¯ Future goal                               â”‚
â”‚ Stage 1 and Stage 2 should produce          â”‚
â”‚ identical output                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Current Status**: We're at Stage 1 - the self-hosted compiler exists and works for simple programs, but full bootstrap (Stage 2) is not yet achieved.

## Key Files

```
src/eigenscript/compiler/selfhost/
â”œâ”€â”€ lexer.eigs        # Tokenization (~700 lines)
â”œâ”€â”€ parser.eigs       # AST building (~1800 lines)
â”œâ”€â”€ semantic.eigs     # Variable scoping (~600 lines)
â”œâ”€â”€ codegen.eigs      # LLVM IR generation (~2300 lines)
â””â”€â”€ main.eigs         # Pipeline orchestration (~320 lines)

scripts/
â””â”€â”€ bootstrap_test.sh # Automated testing script

docs/
â”œâ”€â”€ COMPILER_SELF_HOSTING.md      # Complete guide (you are here)
â””â”€â”€ SELF_HOSTING_QUICKSTART.md    # This document
```

## FAQ

### Is this the same as the meta-circular evaluator?

No! EigenScript has **two types** of self-hosting:

1. **Meta-Circular Evaluator** (examples/eval.eigs)
   - An interpreter written in EigenScript
   - Can evaluate itself
   - âœ… Fully working

2. **Self-Hosted Compiler** (src/eigenscript/compiler/selfhost/)
   - A compiler written in EigenScript
   - Generates LLVM IR
   - âš ï¸ Partially working (this guide)

### Why is the compiler in EigenScript when the reference is in Python?

**Education & Validation**: Writing a compiler in EigenScript proves the language is mature and capable.

**Practical Uses**:
- Test the language with real-world complexity
- Find bugs and limitations
- Demonstrate language capabilities
- Foundation for future pure EigenScript toolchain

The Python compiler remains the primary, production-ready compiler.

### Can I use the self-hosted compiler for real projects?

Not yet! It's currently a proof-of-concept with known bugs. Use the Python reference compiler (`eigenscript-compile`) for real work.

### How big is the self-hosted compiler?

- **Total Lines**: ~5700 lines of EigenScript
- **Generated LLVM IR**: ~27000 lines
- **Runtime Library**: ~1700 lines of C
- **Total Project**: ~34000 lines

For comparison:
- TinyCC (a minimal C compiler): ~30000 lines of C
- Go compiler (go 1.0): ~100000 lines of Go
- Rust compiler (rustc): ~500000+ lines of Rust

## Success!

If you got this far and saw the self-hosted compiler in action, you've witnessed something special: **a programming language mature enough to implement its own compiler**.

This is a significant milestone in language design. Many experimental languages never achieve this!

ğŸš€ **Next**: Try reading through the [complete guide](./COMPILER_SELF_HOSTING.md) to understand how it all works internally.

---

**Questions?** Open an issue on GitHub or check the [documentation](./COMPILER_SELF_HOSTING.md).

**Want to help?** See [CONTRIBUTING.md](../CONTRIBUTING.md) to get involved!
