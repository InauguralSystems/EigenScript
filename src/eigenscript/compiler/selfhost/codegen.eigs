# EigenScript Self-Hosting Code Generator
# Written in EigenScript for bootstrapping the compiler
# Generates LLVM IR text from AST
#
# This outputs textual LLVM IR that can be assembled with llvm-as
# and linked with the EigenScript runtime library.

# ============================================================================
# AST Node Type Constants (must match parser.eigs)
# ============================================================================

AST_LITERAL is 1
AST_IDENTIFIER is 2
AST_BINARY_OP is 3
AST_UNARY_OP is 4
AST_RELATION is 5
AST_INDEX is 6
AST_SLICE is 7
AST_MEMBER_ACCESS is 8
AST_LIST_LITERAL is 9
AST_LIST_COMP is 10
AST_INTERROGATIVE is 11
AST_STRUCT_LITERAL is 12

AST_ASSIGNMENT is 20
AST_CONDITIONAL is 21
AST_LOOP is 22
AST_FUNCTION_DEF is 23
AST_RETURN is 24
AST_BREAK is 25
AST_IMPORT is 26
AST_IMPORT_FROM is 27
AST_STRUCT_DEF is 28

AST_PROGRAM is 30

LIT_NUMBER is 1
LIT_STRING is 2
LIT_NULL is 3

OP_PLUS is 1
OP_MINUS is 2
OP_MULTIPLY is 3
OP_DIVIDE is 4
OP_MODULO is 5
OP_EQUALS is 6
OP_NOT_EQUAL is 7
OP_LESS_THAN is 8
OP_LESS_EQUAL is 9
OP_GREATER_THAN is 10
OP_GREATER_EQUAL is 11
OP_AND is 12
OP_OR is 13

UOP_NOT is 1

# ============================================================================
# Code Generator State
# ============================================================================

reg_counter is 0
label_counter is 0
string_counter is 0
in_main is 0

# Output buffer
MAX_OUTPUT is 50000
output_lines is [""]
output_count is 0

# ============================================================================
# String Building Helpers
# These use native string primitives to construct IR text
# ============================================================================

# Build register name: %N
define make_reg of n as:
    num_str is number_to_string of n
    result is string_concat of ["%", num_str]
    return result

# Build label name: labelN
define make_label of n as:
    num_str is number_to_string of n
    result is string_concat of ["label", num_str]
    return result

# Build double constant
define make_double of val as:
    # Check if value is an integer (no fractional part)
    truncated is val - (val % 1)
    if truncated = val:
        # It's an integer, append .0 for LLVM IR
        str is number_to_string of val
        str is string_concat of [str, ".0"]
        return str
    return number_to_string of val

# Concatenate multiple strings (helper)
# Note: Assign list params to locals first to avoid runtime issue
define cat3 of [a, b, c] as:
    x1 is a
    x2 is b
    x3 is c
    t is string_concat of [x1, x2]
    result is string_concat of [t, x3]
    return result

define cat4 of [a, b, c, d] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    result is string_concat of [t2, x4]
    return result

define cat5 of [a, b, c, d, e] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    x5 is e
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    t3 is string_concat of [t2, x4]
    result is string_concat of [t3, x5]
    return result

define cat6 of [a, b, c, d, e, f] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    x5 is e
    x6 is f
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    t3 is string_concat of [t2, x4]
    t4 is string_concat of [t3, x5]
    result is string_concat of [t4, x6]
    return result

define cat7 of [a, b, c, d, e, f, g] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    x5 is e
    x6 is f
    x7 is g
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    t3 is string_concat of [t2, x4]
    t4 is string_concat of [t3, x5]
    t5 is string_concat of [t4, x6]
    result is string_concat of [t5, x7]
    return result

# ============================================================================
# Output Functions
# ============================================================================

define emit of line as:
    # Print directly instead of buffering (EigenList can't store strings)
    print of line
    output_count is output_count + 1
    return 0

define next_reg as:
    reg_counter is reg_counter + 1
    return reg_counter

define next_label as:
    label_counter is label_counter + 1
    return label_counter

# ============================================================================
# Variable Storage
# ============================================================================

MAX_VARS is 1000
var_names is [""]
var_regs is [0]
var_count is 0

define add_var of [name, reg] as:
    x is name
    y is reg
    append of var_names of x
    append of var_regs of y
    var_count is var_count + 1
    return var_count - 1

define lookup_var of name_idx as:
    # name_idx is a numeric index into the string table
    i is var_count - 1
    loop while i >= 0:
        arr_i is i + 1
        stored_idx is var_names[arr_i]
        if stored_idx = name_idx:
            return var_regs[arr_i]
        i is i - 1
    return 0 - 1

# ============================================================================
# LLVM IR Module Header
# ============================================================================

define emit_header as:
    result is emit of "; EigenScript Compiled Module"
    result is emit of "; Generated by self-hosting compiler"
    result is emit of ""
    result is emit of "target triple = \"x86_64-pc-linux-gnu\""
    result is emit of ""
    result is emit of "; Type definitions"
    result is emit of "%EigenValue = type { double, double, double, i64, [100 x double], i32, i32, double, double }"
    result is emit of "%EigenList = type { double*, i64, i64 }"
    result is emit of "%EigenString = type { i8*, i64, i64 }"
    result is emit of ""
    return 0

define emit_runtime_decls as:
    result is emit of "; Runtime declarations"
    result is emit of "declare %EigenValue* @eigen_create(double)"
    result is emit of "declare void @eigen_update(%EigenValue*, double)"
    result is emit of "declare double @eigen_get_value(%EigenValue*)"
    result is emit of "declare void @eigen_destroy(%EigenValue*)"
    result is emit of ""
    result is emit of "declare %EigenList* @eigen_list_create(i64)"
    result is emit of "declare double @eigen_list_get(%EigenList*, i64)"
    result is emit of "declare void @eigen_list_set(%EigenList*, i64, double)"
    result is emit of "declare i64 @eigen_list_length(%EigenList*)"
    result is emit of "declare void @eigen_list_destroy(%EigenList*)"
    result is emit of ""
    result is emit of "declare %EigenString* @eigen_string_create(i8*)"
    result is emit of "declare i64 @eigen_string_length(%EigenString*)"
    result is emit of "declare void @eigen_print_double(double)"
    result is emit of "declare void @eigen_print_string(%EigenString*)"
    result is emit of ""
    result is emit of "declare double @llvm.fabs.f64(double)"
    result is emit of "declare double @llvm.sqrt.f64(double)"
    result is emit of ""
    return 0

# ============================================================================
# Expression Code Generation
# Returns register number containing result
# ============================================================================

# Generate number literal
# Note: AST arrays have dummy at index 0, so use node_idx + 1
define gen_literal of node_idx as:
    arr_idx is node_idx + 1
    num_val is ast_num_value[arr_idx]
    reg is next_reg of 0

    # Emit: %reg = fadd double 0.0, <val>
    reg_str is make_reg of reg
    val_str is make_double of num_val
    line is cat5 of ["  ", reg_str, " = fadd double 0.0, ", val_str, ""]
    result is emit of line

    return reg

# Generate identifier reference
define gen_identifier of node_idx as:
    arr_idx is node_idx + 1
    name_idx is ast_str_index[arr_idx]
    var_reg is lookup_var of name_idx

    if var_reg < 0:
        result is emit of "  ; ERROR: undefined variable"
        return 0

    # Load from alloca
    reg is next_reg of 0
    reg_str is make_reg of reg
    var_str is make_reg of var_reg

    line is cat5 of ["  ", reg_str, " = load double, double* ", var_str, ""]
    result is emit of line

    return reg

# Generate binary operation
define gen_binary_op of node_idx as:
    arr_idx is node_idx + 1
    op_code is ast_num_value[arr_idx]
    left_idx is ast_left[arr_idx]
    right_idx is ast_right[arr_idx]

    # Generate operands
    left_reg is gen_expr of left_idx
    right_reg is gen_expr of right_idx

    left_str is make_reg of left_reg
    right_str is make_reg of right_reg

    reg is next_reg of 0
    reg_str is make_reg of reg

    # Select instruction based on operator
    if op_code = OP_PLUS:
        line is cat7 of ["  ", reg_str, " = fadd double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_MINUS:
        line is cat7 of ["  ", reg_str, " = fsub double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_MULTIPLY:
        line is cat7 of ["  ", reg_str, " = fmul double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_DIVIDE:
        line is cat7 of ["  ", reg_str, " = fdiv double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_MODULO:
        line is cat7 of ["  ", reg_str, " = frem double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_EQUALS:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp oeq double ", left_str, ", ", right_str, ""]
        result is emit of line
        # Convert i1 to double
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_NOT_EQUAL:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp one double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_LESS_THAN:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp olt double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_LESS_EQUAL:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp ole double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_GREATER_THAN:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp ogt double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_GREATER_EQUAL:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp oge double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_AND:
        # and: multiply (both must be non-zero)
        line is cat7 of ["  ", reg_str, " = fmul double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_OR:
        # or: max of absolute values
        line is cat7 of ["  ", reg_str, " = fadd double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    # Default
    result is emit of "  ; unknown binary op"
    return reg

# Generate unary operation
define gen_unary_op of node_idx as:
    arr_idx is node_idx + 1
    op_code is ast_num_value[arr_idx]
    operand_idx is ast_left[arr_idx]

    operand_reg is gen_expr of operand_idx
    operand_str is make_reg of operand_reg

    reg is next_reg of 0
    reg_str is make_reg of reg

    if op_code = UOP_NOT:
        # not: compare to zero, invert
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat5 of ["  ", cmp_str, " = fcmp oeq double ", operand_str, ", 0.0"]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    return reg

# Generate function call (OF operator)
define gen_relation of node_idx as:
    arr_idx is node_idx + 1
    # For now, handle print specially
    left_idx is ast_left[arr_idx]
    right_idx is ast_right[arr_idx]

    # Generate argument
    arg_reg is gen_expr of right_idx
    arg_str is make_reg of arg_reg

    # Call print
    line is cat4 of ["  call void @eigen_print_double(double ", arg_str, ")", ""]
    result is emit of line

    return arg_reg

# Main expression dispatch
define gen_expr of node_idx as:
    arr_idx is node_idx + 1
    node_type is ast_types[arr_idx]

    if node_type = AST_LITERAL:
        return gen_literal of node_idx

    if node_type = AST_IDENTIFIER:
        return gen_identifier of node_idx

    if node_type = AST_BINARY_OP:
        return gen_binary_op of node_idx

    if node_type = AST_UNARY_OP:
        return gen_unary_op of node_idx

    if node_type = AST_RELATION:
        return gen_relation of node_idx

    # Default: return 0
    return 0

# ============================================================================
# Statement Code Generation
# ============================================================================

define gen_assignment of node_idx as:
    arr_idx is node_idx + 1
    name_idx is ast_str_index[arr_idx]
    expr_idx is ast_left[arr_idx]

    # Generate expression value
    expr_reg is gen_expr of expr_idx
    expr_str is make_reg of expr_reg

    # Check if variable exists (using numeric index for comparison)
    var_reg is lookup_var of name_idx

    if var_reg < 0:
        # New variable - allocate
        var_reg is next_reg of 0
        var_str is make_reg of var_reg
        line is cat4 of ["  ", var_str, " = alloca double", ""]
        result is emit of line
        result is add_var of [name_idx, var_reg]

    var_str is make_reg of var_reg

    # Store value
    line is cat6 of ["  store double ", expr_str, ", double* ", var_str, "", ""]
    result is emit of line

    return 0

define gen_return of node_idx as:
    arr_idx is node_idx + 1
    expr_idx is ast_left[arr_idx]
    ret_reg is gen_expr of expr_idx
    ret_str is make_reg of ret_reg

    line is cat4 of ["  ret double ", ret_str, "", ""]
    result is emit of line

    return 0

define gen_conditional of node_idx as:
    arr_idx is node_idx + 1
    cond_idx is ast_left[arr_idx]
    if_start is ast_num_value[arr_idx]
    if_end is ast_right[arr_idx]
    else_info is ast_third[arr_idx]
    else_start is else_info / 100000
    else_end is else_info % 100000

    # Generate condition
    cond_reg is gen_expr of cond_idx
    cond_str is make_reg of cond_reg

    # Convert to i1
    cmp_reg is next_reg of 0
    cmp_str is make_reg of cmp_reg
    line is cat5 of ["  ", cmp_str, " = fcmp one double ", cond_str, ", 0.0"]
    result is emit of line

    # Labels
    then_lbl is next_label of 0
    else_lbl is next_label of 0
    end_lbl is next_label of 0

    then_str is make_label of then_lbl
    else_str is make_label of else_lbl
    end_str is make_label of end_lbl

    # Branch
    line is cat7 of ["  br i1 ", cmp_str, ", label %", then_str, ", label %", else_str, ""]
    result is emit of line
    result is emit of ""

    # Then block
    line is cat3 of [then_str, ":", ""]
    result is emit of line
    result is gen_block of [if_start, if_end]
    line is cat3 of ["  br label %", end_str, ""]
    result is emit of line
    result is emit of ""

    # Else block
    line is cat3 of [else_str, ":", ""]
    result is emit of line
    if else_start != else_end:
        result is gen_block of [else_start, else_end]
    line is cat3 of ["  br label %", end_str, ""]
    result is emit of line
    result is emit of ""

    # End block
    line is cat3 of [end_str, ":", ""]
    result is emit of line

    return 0

define gen_loop of node_idx as:
    arr_idx is node_idx + 1
    cond_idx is ast_left[arr_idx]
    body_start is ast_num_value[arr_idx]
    body_end is ast_right[arr_idx]

    # Labels
    cond_lbl is next_label of 0
    body_lbl is next_label of 0
    end_lbl is next_label of 0

    cond_str is make_label of cond_lbl
    body_str is make_label of body_lbl
    end_str is make_label of end_lbl

    # Jump to condition
    line is cat3 of ["  br label %", cond_str, ""]
    result is emit of line
    result is emit of ""

    # Condition block
    line is cat3 of [cond_str, ":", ""]
    result is emit of line

    cond_reg is gen_expr of cond_idx
    cond_reg_str is make_reg of cond_reg

    cmp_reg is next_reg of 0
    cmp_str is make_reg of cmp_reg
    line is cat5 of ["  ", cmp_str, " = fcmp one double ", cond_reg_str, ", 0.0"]
    result is emit of line

    line is cat7 of ["  br i1 ", cmp_str, ", label %", body_str, ", label %", end_str, ""]
    result is emit of line
    result is emit of ""

    # Body block
    line is cat3 of [body_str, ":", ""]
    result is emit of line
    result is gen_block of [body_start, body_end]
    line is cat3 of ["  br label %", cond_str, ""]
    result is emit of line
    result is emit of ""

    # End block
    line is cat3 of [end_str, ":", ""]
    result is emit of line

    return 0

define gen_function_def of node_idx as:
    arr_idx is node_idx + 1
    name_idx is ast_str_index[arr_idx]
    body_start is ast_children_start[arr_idx]
    body_end is ast_children_end[arr_idx]

    result is emit of ""
    line is cat3 of ["define double @", name_idx, "() {"]
    result is emit of line
    result is emit of "entry:"

    result is gen_block of [body_start, body_end]

    result is emit of "  ret double 0.0"
    result is emit of "}"
    result is emit of ""

    return 0

define gen_block of [start, end] as:
    s is start
    e is end
    i is s
    loop while i < e:
        # ast_children also has dummy at index 0
        arr_i is i + 1
        stmt_idx is ast_children[arr_i]
        result is gen_stmt of stmt_idx
        i is i + 1
    return 0

define gen_stmt of node_idx as:
    arr_idx is node_idx + 1
    node_type is ast_types[arr_idx]

    if node_type = AST_ASSIGNMENT:
        return gen_assignment of node_idx

    if node_type = AST_CONDITIONAL:
        return gen_conditional of node_idx

    if node_type = AST_LOOP:
        return gen_loop of node_idx

    if node_type = AST_RETURN:
        return gen_return of node_idx

    if node_type = AST_BREAK:
        result is emit of "  ; break (jump to loop end)"
        return 0

    if node_type = AST_FUNCTION_DEF:
        return gen_function_def of node_idx

    if node_type = AST_STRUCT_DEF:
        result is emit of "  ; struct definition"
        return 0

    if node_type = AST_IMPORT:
        return 0

    if node_type = AST_IMPORT_FROM:
        return 0

    # Expression statement
    result is gen_expr of node_idx
    return 0

# ============================================================================
# Main Entry Point
# ============================================================================

define generate of root_node as:
    reg_counter is 0
    label_counter is 0
    output_count is 0
    var_count is 0

    result is emit_header of 0
    result is emit_runtime_decls of 0

    result is emit of "; Main function"
    result is emit of "define i32 @main() {"
    result is emit of "entry:"

    in_main is 1

    arr_idx is root_node + 1
    start is ast_children_start[arr_idx]
    end is ast_children_end[arr_idx]
    result is gen_block of [start, end]

    result is emit of "  ret i32 0"
    result is emit of "}"

    in_main is 0

    return output_count

define print_ir as:
    # IR is now printed directly in emit(), no buffering needed
    return output_count

# Initialize codegen state
define init_codegen as:
    reg_counter is 0
    label_counter is 0
    string_counter is 0
    in_main is 0
    output_lines is []
    output_count is 0
    return 0

