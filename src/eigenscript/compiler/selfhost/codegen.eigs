# EigenScript Self-Hosting Code Generator
# Written in EigenScript for bootstrapping the compiler
# Generates LLVM IR text from AST
#
# This outputs textual LLVM IR that can be assembled with llvm-as
# and linked with the EigenScript runtime library.

# ============================================================================
# AST Node Type Constants (must match parser.eigs)
# ============================================================================

AST_LITERAL is 1
AST_IDENTIFIER is 2
AST_BINARY_OP is 3
AST_UNARY_OP is 4
AST_RELATION is 5
AST_INDEX is 6
AST_SLICE is 7
AST_MEMBER_ACCESS is 8
AST_LIST_LITERAL is 9
AST_LIST_COMP is 10
AST_INTERROGATIVE is 11
AST_STRUCT_LITERAL is 12

AST_ASSIGNMENT is 20
AST_CONDITIONAL is 21
AST_LOOP is 22
AST_FUNCTION_DEF is 23
AST_RETURN is 24
AST_BREAK is 25
AST_IMPORT is 26
AST_IMPORT_FROM is 27
AST_STRUCT_DEF is 28
AST_INDEXED_ASSIGNMENT is 29

AST_PROGRAM is 30

LIT_NUMBER is 1
LIT_STRING is 2
LIT_NULL is 3

OP_PLUS is 1
OP_MINUS is 2
OP_MULTIPLY is 3
OP_DIVIDE is 4
OP_MODULO is 5
OP_EQUALS is 6
OP_NOT_EQUAL is 7
OP_LESS_THAN is 8
OP_LESS_EQUAL is 9
OP_GREATER_THAN is 10
OP_GREATER_EQUAL is 11
OP_AND is 12
OP_OR is 13

UOP_NOT is 1

# ============================================================================
# Code Generator State
# ============================================================================

reg_counter is 0
label_counter is 0
string_counter is 0
in_main is 0

# Loop break label stack (for nested loops)
# Current loop's exit label number (0 if not in loop)
current_loop_exit_label is 0

# Output buffer
MAX_OUTPUT is 50000
output_lines is [""]
output_count is 0

# ============================================================================
# String Building Helpers
# These use native string primitives to construct IR text
# ============================================================================

# Build register name: %N
define make_reg of n as:
    num_str is number_to_string of n
    result is string_concat of ["%", num_str]
    return result

# Build label name: labelN
define make_label of n as:
    num_str is number_to_string of n
    result is string_concat of ["label", num_str]
    return result

# Build double constant
define make_double of val as:
    # Check if value is an integer (no fractional part)
    truncated is val - (val % 1)
    if truncated = val:
        # It's an integer, append .0 for LLVM IR
        str is number_to_string of val
        str is string_concat of [str, ".0"]
        return str
    return number_to_string of val

# Concatenate multiple strings (helper)
# Note: Assign list params to locals first to avoid runtime issue
define cat3 of [a, b, c] as:
    x1 is a
    x2 is b
    x3 is c
    t is string_concat of [x1, x2]
    result is string_concat of [t, x3]
    return result

define cat4 of [a, b, c, d] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    result is string_concat of [t2, x4]
    return result

define cat5 of [a, b, c, d, e] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    x5 is e
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    t3 is string_concat of [t2, x4]
    result is string_concat of [t3, x5]
    return result

define cat6 of [a, b, c, d, e, f] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    x5 is e
    x6 is f
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    t3 is string_concat of [t2, x4]
    t4 is string_concat of [t3, x5]
    result is string_concat of [t4, x6]
    return result

define cat7 of [a, b, c, d, e, f, g] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    x5 is e
    x6 is f
    x7 is g
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    t3 is string_concat of [t2, x4]
    t4 is string_concat of [t3, x5]
    t5 is string_concat of [t4, x6]
    result is string_concat of [t5, x7]
    return result

# ============================================================================
# Output Functions
# ============================================================================

define emit of line as:
    # Print directly instead of buffering (EigenList can't store strings)
    print of line
    output_count is output_count + 1
    return 0

define next_reg as:
    reg_counter is reg_counter + 1
    return reg_counter

define next_label as:
    label_counter is label_counter + 1
    return label_counter

# ============================================================================
# Variable Storage
# ============================================================================

MAX_VARS is 1000
var_names is [""]
var_regs is [0]
var_count is 0

define add_var of [name, reg] as:
    x is name
    y is reg
    append of var_names of x
    append of var_regs of y
    var_count is var_count + 1
    return var_count - 1

define lookup_var of name_idx as:
    # name_idx is a numeric index into the string table
    i is var_count - 1
    loop while i >= 0:
        arr_i is i + 1
        stored_idx is var_names[arr_i]
        if stored_idx = name_idx:
            return var_regs[arr_i]
        i is i - 1
    return 0 - 1

# ============================================================================
# LLVM IR Module Header
# ============================================================================

define emit_header as:
    result is emit of "; EigenScript Compiled Module"
    result is emit of "; Generated by self-hosting compiler"
    result is emit of ""
    result is emit of "target triple = \"x86_64-pc-linux-gnu\""
    result is emit of ""
    result is emit of "; Type definitions"
    result is emit of "%EigenValue = type { double, double, double, i64, [100 x double], i32, i32, double, double }"
    result is emit of "%EigenList = type { double*, i64, i64 }"
    result is emit of "%EigenString = type { i8*, i64, i64 }"
    result is emit of ""
    return 0

define emit_runtime_decls as:
    result is emit of "; Runtime declarations"
    result is emit of "declare %EigenValue* @eigen_create(double)"
    result is emit of "declare void @eigen_update(%EigenValue*, double)"
    result is emit of "declare double @eigen_get_value(%EigenValue*)"
    result is emit of "declare void @eigen_destroy(%EigenValue*)"
    result is emit of ""
    result is emit of "; List operations"
    result is emit of "declare %EigenList* @eigen_list_create(i64)"
    result is emit of "declare double @eigen_list_get(%EigenList*, i64)"
    result is emit of "declare void @eigen_list_set(%EigenList*, i64, double)"
    result is emit of "declare i64 @eigen_list_length(%EigenList*)"
    result is emit of "declare void @eigen_list_destroy(%EigenList*)"
    result is emit of "declare %EigenList* @eigen_double_to_list(double)"
    result is emit of "declare double @eigen_list_to_double(%EigenList*)"
    result is emit of ""
    result is emit of "; String operations"
    result is emit of "declare %EigenString* @eigen_string_create(i8*)"
    result is emit of "declare i64 @eigen_string_length(%EigenString*)"
    result is emit of "declare i64 @eigen_string_length_val(double)"
    result is emit of "declare double @eigen_string_equals_val(double, double)"
    result is emit of "declare double @eigen_string_concat_list(...)"
    result is emit of ""
    result is emit of "; I/O operations"
    result is emit of "declare void @eigen_print_double(double)"
    result is emit of "declare void @eigen_print_string(%EigenString*)"
    result is emit of ""
    result is emit of "; Math intrinsics"
    result is emit of "declare double @llvm.fabs.f64(double)"
    result is emit of "declare double @llvm.sqrt.f64(double)"
    result is emit of ""
    return 0

# ============================================================================
# Expression Code Generation
# Returns register number containing result
# ============================================================================

# Generate literal (number, string, null)
# Note: AST arrays have dummy at index 0, so use node_idx + 1
# For literals: ast_num_value has the value (for numbers) or type (LIT_STRING=2, LIT_NULL=3)
#              ast_str_index has the type (for numbers) or string table index (for strings)
define gen_literal of node_idx as:
    arr_idx is node_idx + 1
    num_val is ast_num_value[arr_idx]
    str_idx is ast_str_index[arr_idx]
    reg is next_reg of 0
    reg_str is make_reg of reg

    # Check literal type
    # LIT_NUMBER=1: num_val is actual value, str_idx is 1
    # LIT_STRING=2: num_val is 2, str_idx is string table index
    # LIT_NULL=3: num_val is 3

    if num_val = LIT_STRING:
        # String literal - emit reference to string constant
        # For now, we encode string as: (string_table_index * 1000000) + marker
        # Runtime can decode this to look up the actual string
        # Actually, simpler: just store the string index directly
        # The runtime will handle string operations via builtin functions
        marker is 1000000000
        encoded is marker + str_idx
        val_str is make_double of encoded
        line is cat5 of ["  ", reg_str, " = fadd double 0.0, ", val_str, ""]
        result is emit of line
        return reg

    if num_val = LIT_NULL:
        # Null literal - return 0
        line is cat4 of ["  ", reg_str, " = fadd double 0.0, 0.0", ""]
        result is emit of line
        return reg

    # Default: number literal
    val_str is make_double of num_val
    line is cat5 of ["  ", reg_str, " = fadd double 0.0, ", val_str, ""]
    result is emit of line
    return reg

# Generate identifier reference
define gen_identifier of node_idx as:
    arr_idx is node_idx + 1
    name_idx is ast_str_index[arr_idx]
    var_reg is lookup_var of name_idx

    if var_reg < 0:
        result is emit of "  ; ERROR: undefined variable"
        return 0

    # Load from alloca
    reg is next_reg of 0
    reg_str is make_reg of reg
    var_str is make_reg of var_reg

    line is cat5 of ["  ", reg_str, " = load double, double* ", var_str, ""]
    result is emit of line

    return reg

# Generate binary operation
define gen_binary_op of node_idx as:
    arr_idx is node_idx + 1
    op_code is ast_num_value[arr_idx]
    left_idx is ast_left[arr_idx]
    right_idx is ast_right[arr_idx]

    # Generate operands
    left_reg is gen_expr of left_idx
    right_reg is gen_expr of right_idx

    left_str is make_reg of left_reg
    right_str is make_reg of right_reg

    reg is next_reg of 0
    reg_str is make_reg of reg

    # Select instruction based on operator
    if op_code = OP_PLUS:
        line is cat7 of ["  ", reg_str, " = fadd double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_MINUS:
        line is cat7 of ["  ", reg_str, " = fsub double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_MULTIPLY:
        line is cat7 of ["  ", reg_str, " = fmul double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_DIVIDE:
        line is cat7 of ["  ", reg_str, " = fdiv double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_MODULO:
        line is cat7 of ["  ", reg_str, " = frem double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_EQUALS:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp oeq double ", left_str, ", ", right_str, ""]
        result is emit of line
        # Convert i1 to double
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_NOT_EQUAL:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp one double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_LESS_THAN:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp olt double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_LESS_EQUAL:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp ole double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_GREATER_THAN:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp ogt double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_GREATER_EQUAL:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp oge double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_AND:
        # and: multiply (both must be non-zero)
        line is cat7 of ["  ", reg_str, " = fmul double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_OR:
        # or: max of absolute values
        line is cat7 of ["  ", reg_str, " = fadd double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    # Default
    result is emit of "  ; unknown binary op"
    return reg

# Generate unary operation
define gen_unary_op of node_idx as:
    arr_idx is node_idx + 1
    op_code is ast_num_value[arr_idx]
    operand_idx is ast_left[arr_idx]

    operand_reg is gen_expr of operand_idx
    operand_str is make_reg of operand_reg

    reg is next_reg of 0
    reg_str is make_reg of reg

    if op_code = UOP_NOT:
        # not: compare to zero, invert
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat5 of ["  ", cmp_str, " = fcmp oeq double ", operand_str, ", 0.0"]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    return reg

# Generate function call (OF operator)
define gen_relation of node_idx as:
    arr_idx is node_idx + 1
    left_idx is ast_left[arr_idx]
    right_idx is ast_right[arr_idx]

    # Get function name from left side (should be identifier)
    left_arr_idx is left_idx + 1
    left_type is ast_types[left_arr_idx]

    func_name is ""
    if left_type = AST_IDENTIFIER:
        name_idx is ast_str_index[left_arr_idx]
        func_name is get_string of name_idx

    # Check if right side is a list literal (multiple arguments)
    right_arr_idx is right_idx + 1
    right_type is ast_types[right_arr_idx]

    # Collect argument registers
    arg_regs is [0]
    arg_count is 0

    if right_type = AST_LIST_LITERAL:
        # Multiple arguments in a list
        arg_start is ast_children_start[right_arr_idx]
        arg_end is ast_children_end[right_arr_idx]
        i is arg_start
        loop while i < arg_end:
            arg_arr_i is i + 1
            arg_node is ast_children[arg_arr_i]
            arg_reg is gen_expr of arg_node
            append of arg_regs of arg_reg
            arg_count is arg_count + 1
            i is i + 1
    else:
        # Single argument
        arg_reg is gen_expr of right_idx
        append of arg_regs of arg_reg
        arg_count is 1

    # Handle builtin functions
    is_print is string_equals of [func_name, "print"]
    if is_print = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        line is cat4 of ["  call void @eigen_print_double(double ", arg_str, ")", ""]
        result is emit of line
        return first_arg

    # Handle append builtin (special form: append of list of value)
    is_append is string_equals of [func_name, "append"]
    if is_append = 1:
        # append takes (list, value) - for now just return 0
        return 0

    # Handle string builtins
    is_string_length is string_equals of [func_name, "string_length"]
    if is_string_length = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call i64 @eigen_string_length_val(double ", arg_str, ")", ""]
        result is emit of line
        # Convert i64 to double
        reg2 is next_reg of 0
        reg2_str is make_reg of reg2
        line is cat6 of ["  ", reg2_str, " = sitofp i64 ", reg_str, " to double", ""]
        result is emit of line
        return reg2

    is_string_equals is string_equals of [func_name, "string_equals"]
    if is_string_equals = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_string_equals_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    is_string_concat is string_equals of [func_name, "string_concat"]
    if is_string_concat = 1:
        # string_concat takes a list of strings - handle specially
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_string_concat_list(...)", ""]
        result is emit of line
        return reg

    # User-defined function call
    # Build argument list string
    args_str is ""
    i is 1
    loop while i <= arg_count:
        arg_reg is arg_regs[i]
        arg_str is make_reg of arg_reg
        if i = 1:
            args_str is cat3 of ["double ", arg_str, ""]
        else:
            args_str is cat5 of [args_str, ", double ", arg_str, "", ""]
        i is i + 1

    # Generate call instruction
    reg is next_reg of 0
    reg_str is make_reg of reg
    line is cat7 of ["  ", reg_str, " = call double @", func_name, "(", args_str, ")"]
    result is emit of line
    return reg

# Generate list indexing: list[index]
define gen_index of node_idx as:
    arr_idx is node_idx + 1
    list_idx is ast_left[arr_idx]
    index_idx is ast_right[arr_idx]

    # Generate list expression
    list_reg is gen_expr of list_idx
    list_str is make_reg of list_reg

    # Generate index expression
    index_reg is gen_expr of index_idx
    index_str is make_reg of index_reg

    # Convert index to i64
    idx_i64_reg is next_reg of 0
    idx_i64_str is make_reg of idx_i64_reg
    line is cat6 of ["  ", idx_i64_str, " = fptosi double ", index_str, " to i64", ""]
    result is emit of line

    # Call runtime to get list element
    # First convert list handle (double) to list pointer
    list_ptr_reg is next_reg of 0
    list_ptr_str is make_reg of list_ptr_reg
    line is cat6 of ["  ", list_ptr_str, " = call %EigenList* @eigen_double_to_list(double ", list_str, ")", ""]
    result is emit of line

    # Get element from list
    elem_reg is next_reg of 0
    elem_str is make_reg of elem_reg
    line is cat7 of ["  ", elem_str, " = call double @eigen_list_get(%EigenList* ", list_ptr_str, ", i64 ", idx_i64_str, ")"]
    result is emit of line

    return elem_reg

# Generate list literal: [elem1, elem2, ...]
define gen_list_literal of node_idx as:
    arr_idx is node_idx + 1
    start is ast_children_start[arr_idx]
    end is ast_children_end[arr_idx]
    count is end - start

    # Create list with initial capacity
    count_str is number_to_string of count
    list_reg is next_reg of 0
    list_str is make_reg of list_reg
    line is cat5 of ["  ", list_str, " = call %EigenList* @eigen_list_create(i64 ", count_str, ")"]
    result is emit of line

    # Add each element
    i is 0
    loop while i < count:
        elem_arr_idx is start + i + 1
        elem_node is ast_children[elem_arr_idx]
        elem_reg is gen_expr of elem_node
        elem_str is make_reg of elem_reg

        # Convert index to i64
        idx_str is number_to_string of i
        line is cat7 of ["  call void @eigen_list_set(%EigenList* ", list_str, ", i64 ", idx_str, ", double ", elem_str, ")"]
        result is emit of line

        i is i + 1

    # Convert list pointer to double for return
    ret_reg is next_reg of 0
    ret_str is make_reg of ret_reg
    line is cat6 of ["  ", ret_str, " = call double @eigen_list_to_double(%EigenList* ", list_str, ")", ""]
    result is emit of line

    return ret_reg

# Main expression dispatch
define gen_expr of node_idx as:
    arr_idx is node_idx + 1
    node_type is ast_types[arr_idx]

    if node_type = AST_LITERAL:
        return gen_literal of node_idx

    if node_type = AST_IDENTIFIER:
        return gen_identifier of node_idx

    if node_type = AST_BINARY_OP:
        return gen_binary_op of node_idx

    if node_type = AST_UNARY_OP:
        return gen_unary_op of node_idx

    if node_type = AST_RELATION:
        return gen_relation of node_idx

    if node_type = AST_INDEX:
        return gen_index of node_idx

    if node_type = AST_LIST_LITERAL:
        return gen_list_literal of node_idx

    # Default: return 0
    return 0

# ============================================================================
# Statement Code Generation
# ============================================================================

define gen_assignment of node_idx as:
    arr_idx is node_idx + 1
    name_idx is ast_str_index[arr_idx]
    expr_idx is ast_left[arr_idx]

    # Generate expression value
    expr_reg is gen_expr of expr_idx
    expr_str is make_reg of expr_reg

    # Check if variable exists (using numeric index for comparison)
    var_reg is lookup_var of name_idx

    if var_reg < 0:
        # New variable - allocate
        var_reg is next_reg of 0
        var_str is make_reg of var_reg
        line is cat4 of ["  ", var_str, " = alloca double", ""]
        result is emit of line
        result is add_var of [name_idx, var_reg]

    var_str is make_reg of var_reg

    # Store value
    line is cat6 of ["  store double ", expr_str, ", double* ", var_str, "", ""]
    result is emit of line

    return 0

# Generate indexed assignment: list[index] is value
define gen_indexed_assignment of node_idx as:
    arr_idx is node_idx + 1
    list_idx is ast_left[arr_idx]
    index_idx is ast_right[arr_idx]
    value_idx is ast_third[arr_idx]

    # Generate list expression
    list_reg is gen_expr of list_idx
    list_str is make_reg of list_reg

    # Generate index expression
    index_reg is gen_expr of index_idx
    index_str is make_reg of index_reg

    # Generate value expression
    value_reg is gen_expr of value_idx
    value_str is make_reg of value_reg

    # Convert index to i64
    idx_i64_reg is next_reg of 0
    idx_i64_str is make_reg of idx_i64_reg
    line is cat6 of ["  ", idx_i64_str, " = fptosi double ", index_str, " to i64", ""]
    result is emit of line

    # Convert list handle (double) to list pointer
    list_ptr_reg is next_reg of 0
    list_ptr_str is make_reg of list_ptr_reg
    line is cat6 of ["  ", list_ptr_str, " = call %EigenList* @eigen_double_to_list(double ", list_str, ")", ""]
    result is emit of line

    # Set element in list
    line is cat7 of ["  call void @eigen_list_set(%EigenList* ", list_ptr_str, ", i64 ", idx_i64_str, ", double ", value_str, ")"]
    result is emit of line

    return 0

define gen_return of node_idx as:
    arr_idx is node_idx + 1
    expr_idx is ast_left[arr_idx]
    ret_reg is gen_expr of expr_idx
    ret_str is make_reg of ret_reg

    line is cat4 of ["  ret double ", ret_str, "", ""]
    result is emit of line

    return 0

define gen_conditional of node_idx as:
    arr_idx is node_idx + 1
    cond_idx is ast_left[arr_idx]
    if_start is ast_num_value[arr_idx]
    if_end is ast_right[arr_idx]
    else_info is ast_third[arr_idx]
    else_start is else_info / 100000
    else_end is else_info % 100000

    # Generate condition
    cond_reg is gen_expr of cond_idx
    cond_str is make_reg of cond_reg

    # Convert to i1
    cmp_reg is next_reg of 0
    cmp_str is make_reg of cmp_reg
    line is cat5 of ["  ", cmp_str, " = fcmp one double ", cond_str, ", 0.0"]
    result is emit of line

    # Labels
    then_lbl is next_label of 0
    else_lbl is next_label of 0
    end_lbl is next_label of 0

    then_str is make_label of then_lbl
    else_str is make_label of else_lbl
    end_str is make_label of end_lbl

    # Branch
    line is cat7 of ["  br i1 ", cmp_str, ", label %", then_str, ", label %", else_str, ""]
    result is emit of line
    result is emit of ""

    # Then block
    line is cat3 of [then_str, ":", ""]
    result is emit of line
    result is gen_block of [if_start, if_end]
    line is cat3 of ["  br label %", end_str, ""]
    result is emit of line
    result is emit of ""

    # Else block
    line is cat3 of [else_str, ":", ""]
    result is emit of line
    if else_start != else_end:
        result is gen_block of [else_start, else_end]
    line is cat3 of ["  br label %", end_str, ""]
    result is emit of line
    result is emit of ""

    # End block
    line is cat3 of [end_str, ":", ""]
    result is emit of line

    return 0

define gen_loop of node_idx as:
    arr_idx is node_idx + 1
    cond_idx is ast_left[arr_idx]
    body_start is ast_num_value[arr_idx]
    body_end is ast_right[arr_idx]

    # Labels
    cond_lbl is next_label of 0
    body_lbl is next_label of 0
    end_lbl is next_label of 0

    cond_str is make_label of cond_lbl
    body_str is make_label of body_lbl
    end_str is make_label of end_lbl

    # Save outer loop's exit label and set current
    outer_exit_label is current_loop_exit_label
    current_loop_exit_label is end_lbl

    # Jump to condition
    line is cat3 of ["  br label %", cond_str, ""]
    result is emit of line
    result is emit of ""

    # Condition block
    line is cat3 of [cond_str, ":", ""]
    result is emit of line

    cond_reg is gen_expr of cond_idx
    cond_reg_str is make_reg of cond_reg

    cmp_reg is next_reg of 0
    cmp_str is make_reg of cmp_reg
    line is cat5 of ["  ", cmp_str, " = fcmp one double ", cond_reg_str, ", 0.0"]
    result is emit of line

    line is cat7 of ["  br i1 ", cmp_str, ", label %", body_str, ", label %", end_str, ""]
    result is emit of line
    result is emit of ""

    # Body block
    line is cat3 of [body_str, ":", ""]
    result is emit of line
    result is gen_block of [body_start, body_end]
    line is cat3 of ["  br label %", cond_str, ""]
    result is emit of line
    result is emit of ""

    # End block
    line is cat3 of [end_str, ":", ""]
    result is emit of line

    # Restore outer loop's exit label
    current_loop_exit_label is outer_exit_label

    return 0

define gen_function_def of node_idx as:
    arr_idx is node_idx + 1
    name_idx is ast_str_index[arr_idx]
    param_count is ast_left[arr_idx]
    children_start is ast_children_start[arr_idx]
    body_start is ast_right[arr_idx]
    body_end is ast_children_end[arr_idx]

    # Get function name string
    func_name is get_string of name_idx

    result is emit of ""

    # Build function signature with parameters
    if param_count = 0:
        line is cat3 of ["define double @", func_name, "() {"]
        result is emit of line
    else:
        # Build complete parameter list string
        param_str is ""
        i is 0
        loop while i < param_count:
            param_arr_idx is children_start + i + 1
            param_name_idx is ast_children[param_arr_idx]
            param_name is get_string of param_name_idx

            if i = 0:
                param_str is cat3 of ["double %param_", param_name, ""]
            else:
                param_str is cat5 of [param_str, ", double %param_", param_name, "", ""]
            i is i + 1

        # Emit complete signature
        line is cat5 of ["define double @", func_name, "(", param_str, ") {"]
        result is emit of line

    result is emit of "entry:"

    # Create alloca for each parameter and store incoming value
    i is 0
    loop while i < param_count:
        param_arr_idx is children_start + i + 1
        param_name_idx is ast_children[param_arr_idx]
        param_name is get_string of param_name_idx

        # Allocate stack space for parameter
        alloc_reg is next_reg of 0
        alloc_str is make_reg of alloc_reg
        line is cat4 of ["  ", alloc_str, " = alloca double", ""]
        result is emit of line

        # Store incoming parameter value
        line is cat6 of ["  store double %param_", param_name, ", double* ", alloc_str, "", ""]
        result is emit of line

        # Register the parameter variable for lookup
        result is add_var of [param_name_idx, alloc_reg]

        i is i + 1

    # Generate body (statements from body_start to body_end)
    result is gen_block of [body_start, body_end]

    result is emit of "  ret double 0.0"
    result is emit of "}"
    result is emit of ""

    return 0

define gen_block of [start, end] as:
    s is start
    e is end
    i is s
    loop while i < e:
        # ast_children also has dummy at index 0
        arr_i is i + 1
        stmt_idx is ast_children[arr_i]
        result is gen_stmt of stmt_idx
        i is i + 1
    return 0

define gen_stmt of node_idx as:
    arr_idx is node_idx + 1
    node_type is ast_types[arr_idx]

    if node_type = AST_ASSIGNMENT:
        return gen_assignment of node_idx

    if node_type = AST_INDEXED_ASSIGNMENT:
        return gen_indexed_assignment of node_idx

    if node_type = AST_CONDITIONAL:
        return gen_conditional of node_idx

    if node_type = AST_LOOP:
        return gen_loop of node_idx

    if node_type = AST_RETURN:
        return gen_return of node_idx

    if node_type = AST_BREAK:
        # Jump to current loop's exit label
        if current_loop_exit_label > 0:
            exit_str is make_label of current_loop_exit_label
            line is cat3 of ["  br label %", exit_str, ""]
            result is emit of line
            # Need a new block after break since br is a terminator
            after_lbl is next_label of 0
            after_str is make_label of after_lbl
            line is cat3 of [after_str, ":", ""]
            result is emit of line
        else:
            result is emit of "  ; ERROR: break outside loop"
        return 0

    if node_type = AST_FUNCTION_DEF:
        return gen_function_def of node_idx

    if node_type = AST_STRUCT_DEF:
        result is emit of "  ; struct definition"
        return 0

    if node_type = AST_IMPORT:
        return 0

    if node_type = AST_IMPORT_FROM:
        return 0

    # Expression statement
    result is gen_expr of node_idx
    return 0

# ============================================================================
# Main Entry Point
# ============================================================================

define generate of root_node as:
    reg_counter is 0
    label_counter is 0
    output_count is 0
    var_count is 0

    result is emit_header of 0
    result is emit_runtime_decls of 0

    result is emit of "; Main function"
    result is emit of "define i32 @main() {"
    result is emit of "entry:"

    in_main is 1

    arr_idx is root_node + 1
    start is ast_children_start[arr_idx]
    end is ast_children_end[arr_idx]
    result is gen_block of [start, end]

    result is emit of "  ret i32 0"
    result is emit of "}"

    in_main is 0

    return output_count

define print_ir as:
    # IR is now printed directly in emit(), no buffering needed
    return output_count

# Initialize codegen state
define init_codegen as:
    reg_counter is 0
    label_counter is 0
    string_counter is 0
    in_main is 0
    output_lines is []
    output_count is 0
    return 0

print of 666
