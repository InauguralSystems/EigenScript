# EigenScript Self-Hosting Code Generator
# Written in EigenScript for bootstrapping the compiler
# Generates LLVM IR text from AST
#
# This outputs textual LLVM IR that can be assembled with llvm-as
# and linked with the EigenScript runtime library.

# Note: Uses lexer_get_string directly (mangled name) for cross-module call

# ============================================================================
# AST Node Type Constants (must match parser.eigs)
# ============================================================================

AST_LITERAL is 1
AST_IDENTIFIER is 2
AST_BINARY_OP is 3
AST_UNARY_OP is 4
AST_RELATION is 5
AST_INDEX is 6
AST_SLICE is 7
AST_MEMBER_ACCESS is 8
AST_LIST_LITERAL is 9
AST_LIST_COMP is 10
AST_INTERROGATIVE is 11
AST_STRUCT_LITERAL is 12

AST_ASSIGNMENT is 20
AST_CONDITIONAL is 21
AST_LOOP is 22
AST_FUNCTION_DEF is 23
AST_RETURN is 24
AST_BREAK is 25
AST_CONTINUE is 26
AST_IMPORT is 27
AST_IMPORT_FROM is 28
AST_STRUCT_DEF is 29
AST_INDEXED_ASSIGNMENT is 30

AST_PROGRAM is 31

LIT_NUMBER is 1
LIT_STRING is 2
LIT_NULL is 3

OP_PLUS is 1
OP_MINUS is 2
OP_MULTIPLY is 3
OP_DIVIDE is 4
OP_MODULO is 5
OP_EQUALS is 6
OP_NOT_EQUAL is 7
OP_LESS_THAN is 8
OP_LESS_EQUAL is 9
OP_GREATER_THAN is 10
OP_GREATER_EQUAL is 11
OP_AND is 12
OP_OR is 13

UOP_NOT is 1

# Interrogative token types (must match lexer.eigs)
TT_WHO is 20
TT_WHAT is 21
TT_WHEN is 22
TT_WHERE is 23
TT_WHY is 24
TT_HOW is 25

# ============================================================================
# Code Generator State
# ============================================================================

reg_counter is 0
label_counter is 0
string_counter is 0
in_main is 0

# Loop break/continue label stack (for nested loops)
# Current loop's exit label number (0 if not in loop)
current_loop_exit_label is 0
# Current loop's condition label number (0 if not in loop)
current_loop_cond_label is 0

# Output buffer
MAX_OUTPUT is 50000
output_lines is [""]
output_count is 0

# ============================================================================
# String Building Helpers
# These use native string primitives to construct IR text
# ============================================================================

# Build register name: %N
define make_reg of n as:
    num_str is number_to_string of n
    result is string_concat of ["%", num_str]
    return result

# Build label name: labelN
define make_label of n as:
    num_str is number_to_string of n
    result is string_concat of ["label", num_str]
    return result

# Build double constant
define make_double of val as:
    # Check if value is an integer (no fractional part)
    truncated is val - (val % 1)
    if truncated = val:
        # It's an integer, append .0 for LLVM IR
        str is number_to_string of val
        str is string_concat of [str, ".0"]
        return str
    return number_to_string of val

# Concatenate multiple strings (helper)
# Note: Assign list params to locals first to avoid runtime issue
define cat3 of [a, b, c] as:
    x1 is a
    x2 is b
    x3 is c
    t is string_concat of [x1, x2]
    result is string_concat of [t, x3]
    return result

define cat4 of [a, b, c, d] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    result is string_concat of [t2, x4]
    return result

define cat5 of [a, b, c, d, e] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    x5 is e
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    t3 is string_concat of [t2, x4]
    result is string_concat of [t3, x5]
    return result

define cat6 of [a, b, c, d, e, f] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    x5 is e
    x6 is f
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    t3 is string_concat of [t2, x4]
    t4 is string_concat of [t3, x5]
    result is string_concat of [t4, x6]
    return result

define cat7 of [a, b, c, d, e, f, g] as:
    x1 is a
    x2 is b
    x3 is c
    x4 is d
    x5 is e
    x6 is f
    x7 is g
    t1 is string_concat of [x1, x2]
    t2 is string_concat of [t1, x3]
    t3 is string_concat of [t2, x4]
    t4 is string_concat of [t3, x5]
    t5 is string_concat of [t4, x6]
    result is string_concat of [t5, x7]
    return result

# ============================================================================
# Output Functions
# ============================================================================

define emit of line as:
    # Print directly instead of buffering (EigenList can't store strings)
    print of line
    output_count is output_count + 1
    return 0

define next_reg as:
    reg_counter is reg_counter + 1
    return reg_counter

define next_label as:
    label_counter is label_counter + 1
    return label_counter

# ============================================================================
# Variable Storage
# ============================================================================

MAX_VARS is 1000
var_names is [""]
var_regs is [0]
var_count is 0

# Struct Storage - maps struct names to their field lists
# struct_names[i] = string index of struct name
# struct_field_counts[i] = number of fields in struct i
# struct_fields[i] = starting index in struct_field_names for struct i's fields
# struct_field_names = flat array of field name string indices
MAX_STRUCTS is 100
struct_names is [0]
struct_field_counts is [0]
struct_fields is [0]
struct_field_names is [0]
struct_count is 0
struct_field_total is 0

define add_struct of [name_idx, field_count] as:
    append of struct_names of name_idx
    append of struct_field_counts of field_count
    append of struct_fields of struct_field_total
    struct_count is struct_count + 1
    return struct_count - 1

define add_struct_field of field_name_idx as:
    append of struct_field_names of field_name_idx
    struct_field_total is struct_field_total + 1
    return struct_field_total - 1

define lookup_struct of name_idx as:
    i is struct_count - 1
    loop while i >= 0:
        arr_i is i + 1
        stored_idx is struct_names[arr_i]
        if stored_idx = name_idx:
            return i
        i is i - 1
    return 0 - 1

define lookup_struct_field of [struct_idx, field_name_idx] as:
    arr_i is struct_idx + 1
    field_start is struct_fields[arr_i]
    field_count is struct_field_counts[arr_i]
    i is 0
    loop while i < field_count:
        field_arr_i is field_start + i + 1
        stored_field is struct_field_names[field_arr_i]
        if stored_field = field_name_idx:
            return i
        i is i + 1
    return 0 - 1

define add_var of [name, reg] as:
    x is name
    y is reg
    append of var_names of x
    append of var_regs of y
    var_count is var_count + 1
    return var_count - 1

define lookup_var of name_idx as:
    # name_idx is a numeric index into the string table
    i is var_count - 1
    loop while i >= 0:
        arr_i is i + 1
        stored_idx is var_names[arr_i]
        if stored_idx = name_idx:
            return var_regs[arr_i]
        i is i - 1
    return 0 - 1

# ============================================================================
# LLVM IR Module Header
# ============================================================================

define emit_header as:
    result is emit of "; EigenScript Compiled Module"
    result is emit of "; Generated by self-hosting compiler"
    result is emit of ""
    result is emit of "target triple = \"x86_64-pc-linux-gnu\""
    result is emit of ""
    result is emit of "; Type definitions"
    result is emit of "%EigenValue = type { double, double, double, i64, [100 x double], i32, i32, double, double }"
    result is emit of "%EigenList = type { double*, i64, i64 }"
    result is emit of "%EigenString = type { i8*, i64, i64 }"
    result is emit of ""
    return 0

define emit_runtime_decls as:
    result is emit of "; Runtime declarations"
    result is emit of "declare %EigenValue* @eigen_create(double)"
    result is emit of "declare void @eigen_update(%EigenValue*, double)"
    result is emit of "declare double @eigen_get_value(%EigenValue*)"
    result is emit of "declare void @eigen_destroy(%EigenValue*)"
    result is emit of ""
    result is emit of "; List operations"
    result is emit of "declare %EigenList* @eigen_list_create(i64)"
    result is emit of "declare double @eigen_list_get(%EigenList*, i64)"
    result is emit of "declare void @eigen_list_set(%EigenList*, i64, double)"
    result is emit of "declare i64 @eigen_list_length(%EigenList*)"
    result is emit of "declare void @eigen_list_destroy(%EigenList*)"
    result is emit of "declare %EigenList* @eigen_double_to_list(double)"
    result is emit of "declare double @eigen_list_to_double(%EigenList*)"
    result is emit of ""
    result is emit of "; String operations"
    result is emit of "declare %EigenString* @eigen_string_create(i8*)"
    result is emit of "declare i64 @eigen_string_length(%EigenString*)"
    result is emit of "declare i64 @eigen_string_length_val(double)"
    result is emit of "declare double @eigen_string_equals_val(double, double)"
    result is emit of "declare double @eigen_string_concat_val(double, double)"
    result is emit of "declare double @eigen_char_at_val(double, double)"
    result is emit of "declare double @eigen_substring_val(double, double, double)"
    result is emit of "declare double @eigen_number_to_string_val(double)"
    result is emit of "declare double @eigen_string_to_number_val(double)"
    result is emit of "declare double @eigen_char_is_digit_val(double)"
    result is emit of "declare double @eigen_char_is_alpha_val(double)"
    result is emit of "declare double @eigen_char_is_whitespace_val(double)"
    result is emit of "declare double @eigen_string_to_double(%EigenString*)"
    result is emit of "declare %EigenString* @eigen_double_to_string(double)"
    result is emit of "declare void @eigen_list_append_val(double, double)"
    result is emit of ""
    result is emit of "; I/O operations"
    result is emit of "declare void @eigen_print_double(double)"
    result is emit of "declare void @eigen_print_string(%EigenString*)"
    result is emit of "declare void @eigen_print_string_val(double)"
    result is emit of "declare void @eigen_print_val(double)"
    result is emit of ""
    result is emit of "; Math intrinsics"
    result is emit of "declare double @llvm.fabs.f64(double)"
    result is emit of "declare double @llvm.sqrt.f64(double)"
    result is emit of ""
    result is emit of "; Interrogative operations"
    result is emit of "declare double @eigen_what_is(double)"
    result is emit of "declare double @eigen_who_is(double)"
    result is emit of "declare double @eigen_why_is(double)"
    result is emit of "declare double @eigen_how_is(double)"
    result is emit of "declare double @eigen_when_is(double)"
    result is emit of "declare double @eigen_where_is(double)"
    result is emit of ""
    result is emit of "; CLI argument operations"
    result is emit of "declare void @eigen_init_args(i32, i8**)"
    result is emit of "declare double @eigen_get_argc()"
    result is emit of "declare double @eigen_get_arg(double)"
    result is emit of ""
    result is emit of "; File I/O operations"
    result is emit of "declare double @eigen_file_read_val(double)"
    result is emit of ""
    result is emit of "; List operations (additional)"
    result is emit of "declare double @eigen_list_length_val(double)"
    result is emit of ""
    result is emit of "; Matrix operations"
    result is emit of "declare double @eigen_matrix_zeros_val(double, double)"
    result is emit of "declare double @eigen_matrix_ones_val(double, double)"
    result is emit of "declare double @eigen_matrix_identity_val(double)"
    result is emit of "declare double @eigen_matrix_random_val(double, double)"
    result is emit of "declare double @eigen_matrix_shape_val(double)"
    result is emit of "declare double @eigen_matrix_transpose_val(double)"
    result is emit of "declare double @eigen_matrix_add_val(double, double)"
    result is emit of "declare double @eigen_matrix_scale_val(double, double)"
    result is emit of "declare double @eigen_matrix_matmul_val(double, double)"
    result is emit of "declare double @eigen_matrix_sum_val(double)"
    result is emit of "declare double @eigen_matrix_mean_val(double)"
    result is emit of "declare double @eigen_matrix_reshape_val(double, double, double)"
    result is emit of "declare double @eigen_matrix_slice_val(double, double, double)"
    result is emit of "declare double @eigen_matrix_concat_val(double, double)"
    result is emit of ""
    result is emit of "; Neural network activations"
    result is emit of "declare double @eigen_relu_matrix_val(double)"
    result is emit of "declare double @eigen_gelu_matrix_val(double)"
    result is emit of "declare double @eigen_softmax_matrix_val(double)"
    result is emit of "declare double @eigen_layer_norm_matrix_val(double)"
    result is emit of ""
    result is emit of "; Transformer operations"
    result is emit of "declare double @eigen_embedding_lookup_val(double, double)"
    result is emit of "declare double @eigen_sinusoidal_pe_val(double, double)"
    result is emit of "declare double @eigen_causal_mask_val(double)"
    result is emit of ""
    result is emit of "; String escaping for LLVM IR"
    result is emit of "declare double @eigen_escape_string_val(double)"
    result is emit of ""
    result is emit of "; Slice operations"
    result is emit of "declare double @eigen_list_slice_val(double, double, double)"
    result is emit of "declare double @eigen_string_slice_val(double, double, double)"
    result is emit of ""
    result is emit of "; Math functions"
    result is emit of "declare double @eigen_sqrt_val(double)"
    result is emit of "declare double @eigen_abs_val(double)"
    result is emit of "declare double @eigen_pow_val(double, double)"
    result is emit of "declare double @eigen_log_val(double)"
    result is emit of "declare double @eigen_exp_val(double)"
    result is emit of "declare double @eigen_sin_val(double)"
    result is emit of "declare double @eigen_cos_val(double)"
    result is emit of "declare double @eigen_tan_val(double)"
    result is emit of "declare double @eigen_floor_val(double)"
    result is emit of "declare double @eigen_ceil_val(double)"
    result is emit of "declare double @eigen_round_val(double)"
    result is emit of ""
    result is emit of "; Higher-order functions"
    result is emit of "declare double @eigen_map_val(double, double)"
    result is emit of "declare double @eigen_filter_val(double, double)"
    result is emit of "declare double @eigen_reduce_val(double, double, double)"
    result is emit of ""
    result is emit of "; Predicate operations (geometric state checks)"
    result is emit of "declare double @eigen_is_converged()"
    result is emit of "declare double @eigen_is_stable()"
    result is emit of "declare double @eigen_is_diverging()"
    result is emit of "declare double @eigen_is_improving()"
    result is emit of "declare double @eigen_is_oscillating()"
    result is emit of "declare double @eigen_is_equilibrium()"
    result is emit of "declare double @eigen_is_settled()"
    result is emit of "declare double @eigen_is_balanced()"
    result is emit of "declare double @eigen_is_stuck()"
    result is emit of "declare double @eigen_is_chaotic()"
    result is emit of ""
    result is emit of "; Temporal operators"
    result is emit of "declare double @eigen_was_is(double)"
    result is emit of "declare double @eigen_change_is(double)"
    result is emit of "declare double @eigen_status_is(double)"
    result is emit of "declare double @eigen_trend_is(double)"
    result is emit of ""
    return 0

# Emit all string constants from the string table
define emit_string_constants as:
    result is emit of "; String constants"
    i is 1
    loop while i <= ast_string_count:
        str is lexer_get_string of i
        str_len is string_length of str
        # Length includes null terminator (original length, not escaped)
        total_len is str_len + 1
        len_str is number_to_string of total_len
        i_str is number_to_string of i

        # Escape special characters for LLVM IR: \n -> \0A, \t -> \09, etc.
        escaped_str is escape_string of str

        # Build: @.str.N = private constant [len x i8] c"content\00"
        line is cat5 of ["@.str.", i_str, " = private constant [", len_str, " x i8] c\""]
        line is string_concat of [line, escaped_str]
        line is string_concat of [line, "\\00\""]
        result is emit of line

        i is i + 1
    result is emit of ""
    return 0

# ============================================================================
# Expression Code Generation
# Returns register number containing result
# ============================================================================

# Generate literal (number, string, null)
# Note: AST arrays have dummy at index 0, so use node_idx + 1
# For literals: ast_num_value has the value (for numbers) or type (LIT_STRING=2, LIT_NULL=3)
#              ast_str_index has the type (for numbers) or string table index (for strings)
define gen_literal of node_idx as:
    arr_idx is node_idx + 1
    num_val is ast_num_value[arr_idx]
    str_idx is ast_str_index[arr_idx]

    # Check literal type by examining BOTH fields:
    # LIT_NUMBER=1: str_idx is 1 (type marker), num_val is actual value
    # LIT_STRING=2: num_val is 2 (type marker), str_idx is string table index
    # LIT_NULL=3: num_val is 3 (type marker)
    #
    # IMPORTANT: Must check str_idx = LIT_NUMBER first to detect numbers,
    # because num_val could be ANY value (including 2 which equals LIT_STRING)

    # First check if it's a number (str_idx = LIT_NUMBER = 1)
    if str_idx = LIT_NUMBER:
        # Number literal - num_val contains the actual numeric value
        reg is next_reg of 0
        reg_str is make_reg of reg
        val_str is make_double of num_val
        line is cat5 of ["  ", reg_str, " = fadd double 0.0, ", val_str, ""]
        result is emit of line
        return reg

    # Then check if it's a string (num_val = LIT_STRING = 2)
    if num_val = LIT_STRING:
        # String literal - str_idx is the string table index
        str_content is lexer_get_string of str_idx
        str_len is string_length of str_content
        total_len is str_len + 1
        len_str is number_to_string of total_len
        idx_str is number_to_string of str_idx

        # Get pointer to the global string constant
        # %ptr = getelementptr [N x i8], [N x i8]* @.str.M, i64 0, i64 0
        ptr_reg is next_reg of 0
        ptr_str is make_reg of ptr_reg
        line is cat5 of ["  ", ptr_str, " = getelementptr [", len_str, " x i8], ["]
        line is cat5 of [line, len_str, " x i8]* @.str.", idx_str, ", i64 0, i64 0"]
        result is emit of line

        # Create EigenString* from the C string pointer
        # %str = call %EigenString* @eigen_string_create(i8* %ptr)
        str_reg is next_reg of 0
        str_reg_str is make_reg of str_reg
        line is cat6 of ["  ", str_reg_str, " = call %EigenString* @eigen_string_create(i8* ", ptr_str, ")", ""]
        result is emit of line

        # Convert pointer to double for storage
        # %result = call double @eigen_string_to_double(%EigenString* %str)
        # Allocate result register AFTER intermediate registers to maintain SSA order
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_string_to_double(%EigenString* ", str_reg_str, ")", ""]
        result is emit of line
        return reg

    # Finally check for null (num_val = LIT_NULL = 3)
    if num_val = LIT_NULL:
        # Null literal - return 0
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = fadd double 0.0, 0.0", ""]
        result is emit of line
        return reg

    # Fallback: treat as number with value num_val (shouldn't reach here normally)
    reg is next_reg of 0
    reg_str is make_reg of reg
    val_str is make_double of num_val
    line is cat5 of ["  ", reg_str, " = fadd double 0.0, ", val_str, ""]
    result is emit of line
    return reg

# Generate identifier reference
define gen_identifier of node_idx as:
    arr_idx is node_idx + 1
    name_idx is ast_str_index[arr_idx]

    # Get the identifier name for predicate checking
    ident_name is lexer_get_string of name_idx

    # Check for predicate identifiers (converged, stable, etc.)
    is_converged is string_equals of [ident_name, "converged"]
    if is_converged = 1:
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_is_converged()", ""]
        result is emit of line
        return reg

    is_stable is string_equals of [ident_name, "stable"]
    if is_stable = 1:
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_is_stable()", ""]
        result is emit of line
        return reg

    is_diverging is string_equals of [ident_name, "diverging"]
    if is_diverging = 1:
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_is_diverging()", ""]
        result is emit of line
        return reg

    is_improving is string_equals of [ident_name, "improving"]
    if is_improving = 1:
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_is_improving()", ""]
        result is emit of line
        return reg

    is_oscillating is string_equals of [ident_name, "oscillating"]
    if is_oscillating = 1:
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_is_oscillating()", ""]
        result is emit of line
        return reg

    is_equilibrium is string_equals of [ident_name, "equilibrium"]
    if is_equilibrium = 1:
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_is_equilibrium()", ""]
        result is emit of line
        return reg

    is_settled is string_equals of [ident_name, "settled"]
    if is_settled = 1:
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_is_settled()", ""]
        result is emit of line
        return reg

    is_balanced is string_equals of [ident_name, "balanced"]
    if is_balanced = 1:
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_is_balanced()", ""]
        result is emit of line
        return reg

    is_stuck is string_equals of [ident_name, "stuck"]
    if is_stuck = 1:
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_is_stuck()", ""]
        result is emit of line
        return reg

    is_chaotic is string_equals of [ident_name, "chaotic"]
    if is_chaotic = 1:
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_is_chaotic()", ""]
        result is emit of line
        return reg

    # Regular variable lookup
    var_reg is lookup_var of name_idx

    if var_reg < 0:
        result is emit of "  ; ERROR: undefined variable"
        return 0

    # Load from alloca
    reg is next_reg of 0
    reg_str is make_reg of reg
    var_str is make_reg of var_reg

    line is cat5 of ["  ", reg_str, " = load double, double* ", var_str, ""]
    result is emit of line

    return reg

# Generate binary operation
define gen_binary_op of node_idx as:
    arr_idx is node_idx + 1
    op_code is ast_num_value[arr_idx]
    left_idx is ast_left[arr_idx]
    right_idx is ast_right[arr_idx]

    # Generate operands
    left_reg is gen_expr of left_idx
    right_reg is gen_expr of right_idx

    left_str is make_reg of left_reg
    right_str is make_reg of right_reg

    reg is next_reg of 0
    reg_str is make_reg of reg

    # Select instruction based on operator
    if op_code = OP_PLUS:
        line is cat7 of ["  ", reg_str, " = fadd double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_MINUS:
        line is cat7 of ["  ", reg_str, " = fsub double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_MULTIPLY:
        line is cat7 of ["  ", reg_str, " = fmul double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_DIVIDE:
        line is cat7 of ["  ", reg_str, " = fdiv double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_MODULO:
        line is cat7 of ["  ", reg_str, " = frem double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_EQUALS:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp oeq double ", left_str, ", ", right_str, ""]
        result is emit of line
        # Convert i1 to double
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_NOT_EQUAL:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp one double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_LESS_THAN:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp olt double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_LESS_EQUAL:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp ole double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_GREATER_THAN:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp ogt double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_GREATER_EQUAL:
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat7 of ["  ", cmp_str, " = fcmp oge double ", left_str, ", ", right_str, ""]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    if op_code = OP_AND:
        # and: multiply (both must be non-zero)
        line is cat7 of ["  ", reg_str, " = fmul double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    if op_code = OP_OR:
        # or: max of absolute values
        line is cat7 of ["  ", reg_str, " = fadd double ", left_str, ", ", right_str, ""]
        result is emit of line
        return reg

    # Default
    result is emit of "  ; unknown binary op"
    return reg

# Generate unary operation
define gen_unary_op of node_idx as:
    arr_idx is node_idx + 1
    op_code is ast_num_value[arr_idx]
    operand_idx is ast_left[arr_idx]

    operand_reg is gen_expr of operand_idx
    operand_str is make_reg of operand_reg

    reg is next_reg of 0
    reg_str is make_reg of reg

    if op_code = UOP_NOT:
        # not: compare to zero, invert
        cmp_reg is reg
        cmp_str is make_reg of cmp_reg
        line is cat5 of ["  ", cmp_str, " = fcmp oeq double ", operand_str, ", 0.0"]
        result is emit of line
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = uitofp i1 ", cmp_str, " to double"]
        result is emit of line
        return reg

    return reg

# Generate function call (OF operator)
define gen_relation of node_idx as:
    arr_idx is node_idx + 1
    left_idx is ast_left[arr_idx]
    right_idx is ast_right[arr_idx]

    # Get function name from left side (should be identifier)
    left_arr_idx is left_idx + 1
    left_type is ast_types[left_arr_idx]

    func_name is ""
    if left_type = AST_IDENTIFIER:
        name_idx is ast_str_index[left_arr_idx]
        func_name is lexer_get_string of name_idx

    # Check if right side is a list literal (multiple arguments)
    right_arr_idx is right_idx + 1
    right_type is ast_types[right_arr_idx]

    # Collect argument registers
    arg_regs is [0]
    arg_count is 0

    if right_type = AST_LIST_LITERAL:
        # Multiple arguments in a list
        arg_start is ast_children_start[right_arr_idx]
        arg_end is ast_children_end[right_arr_idx]
        i is arg_start
        loop while i < arg_end:
            arg_arr_i is i + 1
            arg_node is ast_children[arg_arr_i]
            arg_reg is gen_expr of arg_node
            append of arg_regs of arg_reg
            arg_count is arg_count + 1
            i is i + 1
    else:
        # Single argument
        arg_reg is gen_expr of right_idx
        append of arg_regs of arg_reg
        arg_count is 1

    # Handle builtin functions
    is_print is string_equals of [func_name, "print"]
    if is_print = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        # Use eigen_print_val which auto-detects strings vs numbers
        line is cat4 of ["  call void @eigen_print_val(double ", arg_str, ")", ""]
        result is emit of line
        return first_arg

    # Handle append builtin (special form: append of list of value)
    # Syntax parses as: append of (list of value) - a chained relation
    # We need to extract list and value from the nested relation
    is_append is string_equals of [func_name, "append"]
    if is_append = 1:
        # Check if right side is a relation (chained syntax: append of list of value)
        if right_type = AST_RELATION:
            # Right is "list of value" - extract both parts
            list_idx is ast_left[right_arr_idx]
            value_idx is ast_right[right_arr_idx]
            list_reg is gen_expr of list_idx
            value_reg is gen_expr of value_idx
            list_str is make_reg of list_reg
            value_str is make_reg of value_reg
            line is cat6 of ["  call void @eigen_list_append_val(double ", list_str, ", double ", value_str, ")", ""]
            result is emit of line
            return 0
        else:
            # Fallback: assume 2 args in a list (append of [list, value])
            first_arg is arg_regs[1]
            second_arg is arg_regs[2]
            arg1_str is make_reg of first_arg
            arg2_str is make_reg of second_arg
            line is cat6 of ["  call void @eigen_list_append_val(double ", arg1_str, ", double ", arg2_str, ")", ""]
            result is emit of line
            return 0

    # Handle string builtins
    is_string_length is string_equals of [func_name, "string_length"]
    if is_string_length = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call i64 @eigen_string_length_val(double ", arg_str, ")", ""]
        result is emit of line
        # Convert i64 to double
        reg2 is next_reg of 0
        reg2_str is make_reg of reg2
        line is cat6 of ["  ", reg2_str, " = sitofp i64 ", reg_str, " to double", ""]
        result is emit of line
        return reg2

    is_string_equals is string_equals of [func_name, "string_equals"]
    if is_string_equals = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_string_equals_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    is_string_concat is string_equals of [func_name, "string_concat"]
    if is_string_concat = 1:
        # string_concat takes a list of strings as argument [str1, str2, ...]
        # We concatenate them pairwise using eigen_string_concat_val
        # For now, handle 2-element list (most common case)
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_string_concat_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # number_to_string
    is_num_to_str is string_equals of [func_name, "number_to_string"]
    if is_num_to_str = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_number_to_string_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # string_to_number
    is_str_to_num is string_equals of [func_name, "string_to_number"]
    if is_str_to_num = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_string_to_number_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # char_at
    is_char_at is string_equals of [func_name, "char_at"]
    if is_char_at = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_char_at_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # substring
    is_substring is string_equals of [func_name, "substring"]
    if is_substring = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        third_arg is arg_regs[3]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        arg3_str is make_reg of third_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = call double @eigen_substring_val(double ", arg1_str, ", "]
        line is cat5 of [line, "double ", arg2_str, ", double ", arg3_str]
        line is string_concat of [line, ")"]
        result is emit of line
        return reg

    # char_is_digit
    is_char_digit is string_equals of [func_name, "char_is_digit"]
    if is_char_digit = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_char_is_digit_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # char_is_alpha
    is_char_alpha is string_equals of [func_name, "char_is_alpha"]
    if is_char_alpha = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_char_is_alpha_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # char_is_whitespace
    is_char_ws is string_equals of [func_name, "char_is_whitespace"]
    if is_char_ws = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_char_is_whitespace_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # get_argc - returns number of command line arguments
    is_get_argc is string_equals of [func_name, "get_argc"]
    if is_get_argc = 1:
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat4 of ["  ", reg_str, " = call double @eigen_get_argc()", ""]
        result is emit of line
        return reg

    # get_arg - returns command line argument at index
    is_get_arg is string_equals of [func_name, "get_arg"]
    if is_get_arg = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_get_arg(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # file_read - reads file contents as string
    is_file_read is string_equals of [func_name, "file_read"]
    if is_file_read = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_file_read_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # length - returns length of list
    is_length is string_equals of [func_name, "length"]
    if is_length = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_list_length_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # ============================================================
    # Matrix Operations
    # ============================================================

    # matrix_zeros - create matrix of zeros
    is_mzeros is string_equals of [func_name, "matrix_zeros"]
    if is_mzeros = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_matrix_zeros_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # matrix_ones - create matrix of ones
    is_mones is string_equals of [func_name, "matrix_ones"]
    if is_mones = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_matrix_ones_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # matrix_identity - create identity matrix
    is_mident is string_equals of [func_name, "matrix_identity"]
    if is_mident = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_matrix_identity_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # random_matrix - create random matrix
    is_mrandom is string_equals of [func_name, "random_matrix"]
    if is_mrandom = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_matrix_random_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # matrix_shape - get matrix shape
    is_mshape is string_equals of [func_name, "matrix_shape"]
    if is_mshape = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_matrix_shape_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # matrix_transpose - transpose matrix
    is_mtrans is string_equals of [func_name, "matrix_transpose"]
    if is_mtrans = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_matrix_transpose_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # matrix_add - add two matrices
    is_madd is string_equals of [func_name, "matrix_add"]
    if is_madd = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_matrix_add_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # matrix_scale - scale matrix by scalar
    is_mscale is string_equals of [func_name, "matrix_scale"]
    if is_mscale = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_matrix_scale_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # matrix_matmul - matrix multiplication
    is_mmatmul is string_equals of [func_name, "matrix_matmul"]
    if is_mmatmul = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_matrix_matmul_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # matrix_sum - sum of all elements
    is_msum is string_equals of [func_name, "matrix_sum"]
    if is_msum = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_matrix_sum_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # matrix_mean - mean of all elements
    is_mmean is string_equals of [func_name, "matrix_mean"]
    if is_mmean = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_matrix_mean_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # matrix_reshape - reshape matrix
    is_mreshape is string_equals of [func_name, "matrix_reshape"]
    if is_mreshape = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        third_arg is arg_regs[3]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        arg3_str is make_reg of third_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = call double @eigen_matrix_reshape_val(double ", arg1_str, ", "]
        line is cat5 of [line, "double ", arg2_str, ", double ", arg3_str]
        line is string_concat of [line, ")"]
        result is emit of line
        return reg

    # matrix_slice - slice matrix rows
    is_mslice is string_equals of [func_name, "matrix_slice"]
    if is_mslice = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        third_arg is arg_regs[3]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        arg3_str is make_reg of third_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = call double @eigen_matrix_slice_val(double ", arg1_str, ", "]
        line is cat5 of [line, "double ", arg2_str, ", double ", arg3_str]
        line is string_concat of [line, ")"]
        result is emit of line
        return reg

    # matrix_concat - concatenate matrices
    is_mconcat is string_equals of [func_name, "matrix_concat"]
    if is_mconcat = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_matrix_concat_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # ============================================================
    # Neural Network Activations
    # ============================================================

    # relu_matrix - ReLU activation
    is_relu is string_equals of [func_name, "relu_matrix"]
    if is_relu = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_relu_matrix_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # gelu_matrix - GELU activation
    is_gelu is string_equals of [func_name, "gelu_matrix"]
    if is_gelu = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_gelu_matrix_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # softmax_matrix - Softmax activation
    is_softmax is string_equals of [func_name, "softmax_matrix"]
    if is_softmax = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_softmax_matrix_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # layer_norm_matrix - Layer normalization
    is_layernorm is string_equals of [func_name, "layer_norm_matrix"]
    if is_layernorm = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_layer_norm_matrix_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # ============================================================
    # Transformer Operations
    # ============================================================

    # embedding_lookup - lookup embeddings
    is_embed is string_equals of [func_name, "embedding_lookup"]
    if is_embed = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_embedding_lookup_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # sinusoidal_pe - sinusoidal positional encoding
    is_sinpe is string_equals of [func_name, "sinusoidal_pe"]
    if is_sinpe = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_sinusoidal_pe_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # causal_mask - causal attention mask
    is_cmask is string_equals of [func_name, "causal_mask"]
    if is_cmask = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_causal_mask_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # escape_string - escape string for LLVM IR output
    is_escape is string_equals of [func_name, "escape_string"]
    if is_escape = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_escape_string_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # ============================================================
    # Math Functions
    # ============================================================

    # sqrt - square root
    is_sqrt is string_equals of [func_name, "sqrt"]
    if is_sqrt = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_sqrt_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # abs - absolute value
    is_abs is string_equals of [func_name, "abs"]
    if is_abs = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_abs_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # pow - power function (base, exponent)
    is_pow is string_equals of [func_name, "pow"]
    if is_pow = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_pow_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # log - natural logarithm
    is_log is string_equals of [func_name, "log"]
    if is_log = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_log_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # exp - exponential function
    is_exp is string_equals of [func_name, "exp"]
    if is_exp = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_exp_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # sin - sine function
    is_sin is string_equals of [func_name, "sin"]
    if is_sin = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_sin_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # cos - cosine function
    is_cos is string_equals of [func_name, "cos"]
    if is_cos = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_cos_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # tan - tangent function
    is_tan is string_equals of [func_name, "tan"]
    if is_tan = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_tan_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # floor - round down
    is_floor is string_equals of [func_name, "floor"]
    if is_floor = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_floor_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # ceil - round up
    is_ceil is string_equals of [func_name, "ceil"]
    if is_ceil = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_ceil_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # round - round to nearest
    is_round is string_equals of [func_name, "round"]
    if is_round = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_round_val(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # ============================================================
    # Higher-Order Functions
    # ============================================================

    # map - apply function to each element
    is_map is string_equals of [func_name, "map"]
    if is_map = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_map_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # filter - keep elements where predicate is true
    is_filter is string_equals of [func_name, "filter"]
    if is_filter = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat7 of ["  ", reg_str, " = call double @eigen_filter_val(double ", arg1_str, ", double ", arg2_str, ")"]
        result is emit of line
        return reg

    # reduce - fold list to single value
    is_reduce is string_equals of [func_name, "reduce"]
    if is_reduce = 1:
        first_arg is arg_regs[1]
        second_arg is arg_regs[2]
        third_arg is arg_regs[3]
        arg1_str is make_reg of first_arg
        arg2_str is make_reg of second_arg
        arg3_str is make_reg of third_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat5 of ["  ", reg_str, " = call double @eigen_reduce_val(double ", arg1_str, ", "]
        line is cat5 of [line, "double ", arg2_str, ", double ", arg3_str]
        line is string_concat of [line, ")"]
        result is emit of line
        return reg

    # ============================================================
    # Temporal Operators (was, change, status, trend)
    # ============================================================

    # was - previous value
    is_was is string_equals of [func_name, "was"]
    if is_was = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_was_is(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # change - how much value changed
    is_change is string_equals of [func_name, "change"]
    if is_change = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_change_is(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # status - process quality
    is_status is string_equals of [func_name, "status"]
    if is_status = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_status_is(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # trend - direction of change
    is_trend is string_equals of [func_name, "trend"]
    if is_trend = 1:
        first_arg is arg_regs[1]
        arg_str is make_reg of first_arg
        reg is next_reg of 0
        reg_str is make_reg of reg
        line is cat6 of ["  ", reg_str, " = call double @eigen_trend_is(double ", arg_str, ")", ""]
        result is emit of line
        return reg

    # Check if this is a struct constructor
    # Look up func_name in struct table
    left_arr_idx is left_idx + 1
    if left_type = AST_IDENTIFIER:
        func_name_idx is ast_str_index[left_arr_idx]
        struct_idx is lookup_struct of func_name_idx
        if struct_idx >= 0:
            # This is a struct constructor - create a list from arguments
            count_str is number_to_string of arg_count
            list_reg is next_reg of 0
            list_str is make_reg of list_reg
            line is cat5 of ["  ", list_str, " = call %EigenList* @eigen_list_create(i64 ", count_str, ")"]
            result is emit of line

            # Set each element
            i is 1
            loop while i <= arg_count:
                field_reg is arg_regs[i]
                field_str is make_reg of field_reg
                idx is i - 1
                idx_str is number_to_string of idx
                line is cat7 of ["  call void @eigen_list_set(%EigenList* ", list_str, ", i64 ", idx_str, ", double ", field_str, ")"]
                result is emit of line
                i is i + 1

            # Convert to double
            ret_reg is next_reg of 0
            ret_str is make_reg of ret_reg
            line is cat6 of ["  ", ret_str, " = call double @eigen_list_to_double(%EigenList* ", list_str, ")", ""]
            result is emit of line
            return ret_reg

    # User-defined function call
    # Build argument list string
    args_str is ""
    i is 1
    loop while i <= arg_count:
        arg_reg is arg_regs[i]
        arg_str is make_reg of arg_reg
        if i = 1:
            args_str is cat3 of ["double ", arg_str, ""]
        else:
            args_str is cat5 of [args_str, ", double ", arg_str, "", ""]
        i is i + 1

    # Generate call instruction
    reg is next_reg of 0
    reg_str is make_reg of reg
    line is cat7 of ["  ", reg_str, " = call double @", func_name, "(", args_str, ")"]
    result is emit of line
    return reg

# Generate list indexing: list[index]
define gen_index of node_idx as:
    arr_idx is node_idx + 1
    list_idx is ast_left[arr_idx]
    index_idx is ast_right[arr_idx]

    # Generate list expression
    list_reg is gen_expr of list_idx
    list_str is make_reg of list_reg

    # Generate index expression
    index_reg is gen_expr of index_idx
    index_str is make_reg of index_reg

    # Convert index to i64
    idx_i64_reg is next_reg of 0
    idx_i64_str is make_reg of idx_i64_reg
    line is cat6 of ["  ", idx_i64_str, " = fptosi double ", index_str, " to i64", ""]
    result is emit of line

    # Call runtime to get list element
    # First convert list handle (double) to list pointer
    list_ptr_reg is next_reg of 0
    list_ptr_str is make_reg of list_ptr_reg
    line is cat6 of ["  ", list_ptr_str, " = call %EigenList* @eigen_double_to_list(double ", list_str, ")", ""]
    result is emit of line

    # Get element from list
    elem_reg is next_reg of 0
    elem_str is make_reg of elem_reg
    line is cat7 of ["  ", elem_str, " = call double @eigen_list_get(%EigenList* ", list_ptr_str, ", i64 ", idx_i64_str, ")"]
    result is emit of line

    return elem_reg

# Generate list literal: [elem1, elem2, ...]
define gen_list_literal of node_idx as:
    arr_idx is node_idx + 1
    start is ast_children_start[arr_idx]
    end is ast_children_end[arr_idx]
    count is end - start

    # Create list with initial capacity
    count_str is number_to_string of count
    list_reg is next_reg of 0
    list_str is make_reg of list_reg
    line is cat5 of ["  ", list_str, " = call %EigenList* @eigen_list_create(i64 ", count_str, ")"]
    result is emit of line

    # Add each element
    i is 0
    loop while i < count:
        elem_arr_idx is start + i + 1
        elem_node is ast_children[elem_arr_idx]
        elem_reg is gen_expr of elem_node
        elem_str is make_reg of elem_reg

        # Convert index to i64
        idx_str is number_to_string of i
        line is cat7 of ["  call void @eigen_list_set(%EigenList* ", list_str, ", i64 ", idx_str, ", double ", elem_str, ")"]
        result is emit of line

        i is i + 1

    # Convert list pointer to double for return
    ret_reg is next_reg of 0
    ret_str is make_reg of ret_reg
    line is cat6 of ["  ", ret_str, " = call double @eigen_list_to_double(%EigenList* ", list_str, ")", ""]
    result is emit of line

    return ret_reg

# Generate list comprehension: [expr for var in iterable] or [expr for var in iterable if cond]
# AST: left=expr, right=iterable, third=condition (0 if none), str_index=var name
define gen_list_comp of node_idx as:
    arr_idx is node_idx + 1
    expr_idx is ast_left[arr_idx]
    iterable_idx is ast_right[arr_idx]
    cond_idx is ast_third[arr_idx]
    var_name_idx is ast_str_index[arr_idx]

    # Create empty result list
    result_list_reg is next_reg of 0
    result_list_str is make_reg of result_list_reg
    line is cat4 of ["  ", result_list_str, " = call %EigenList* @eigen_list_create(i64 0)", ""]
    result is emit of line

    # Generate iterable expression
    iter_reg is gen_expr of iterable_idx
    iter_str is make_reg of iter_reg

    # Convert to list pointer
    iter_ptr_reg is next_reg of 0
    iter_ptr_str is make_reg of iter_ptr_reg
    line is cat6 of ["  ", iter_ptr_str, " = call %EigenList* @eigen_double_to_list(double ", iter_str, ")", ""]
    result is emit of line

    # Get length of iterable
    len_reg is next_reg of 0
    len_str is make_reg of len_reg
    line is cat6 of ["  ", len_str, " = call i64 @eigen_list_length(%EigenList* ", iter_ptr_str, ")", ""]
    result is emit of line

    # Allocate loop index variable
    idx_alloc_reg is next_reg of 0
    idx_alloc_str is make_reg of idx_alloc_reg
    line is cat4 of ["  ", idx_alloc_str, " = alloca i64", ""]
    result is emit of line
    line is cat4 of ["  store i64 0, i64* ", idx_alloc_str, "", ""]
    result is emit of line

    # Allocate the iteration variable for the comprehension
    var_alloc_reg is next_reg of 0
    var_alloc_str is make_reg of var_alloc_reg
    line is cat4 of ["  ", var_alloc_str, " = alloca double", ""]
    result is emit of line

    # Register the loop variable
    result is add_var of [var_name_idx, var_alloc_reg]

    # Loop labels
    cond_lbl is next_label of 0
    body_lbl is next_label of 0
    end_lbl is next_label of 0
    cond_str is make_label of cond_lbl
    body_str is make_label of body_lbl
    end_str is make_label of end_lbl

    # Jump to condition
    line is cat3 of ["  br label %", cond_str, ""]
    result is emit of line
    result is emit of ""

    # Condition block: check if index < length
    line is cat3 of [cond_str, ":", ""]
    result is emit of line

    curr_idx_reg is next_reg of 0
    curr_idx_str is make_reg of curr_idx_reg
    line is cat6 of ["  ", curr_idx_str, " = load i64, i64* ", idx_alloc_str, "", ""]
    result is emit of line

    cmp_reg is next_reg of 0
    cmp_str is make_reg of cmp_reg
    line is cat7 of ["  ", cmp_str, " = icmp slt i64 ", curr_idx_str, ", ", len_str, ""]
    result is emit of line

    line is cat7 of ["  br i1 ", cmp_str, ", label %", body_str, ", label %", end_str, ""]
    result is emit of line
    result is emit of ""

    # Body block
    line is cat3 of [body_str, ":", ""]
    result is emit of line

    # Get current element from iterable
    elem_reg is next_reg of 0
    elem_str is make_reg of elem_reg
    line is cat7 of ["  ", elem_str, " = call double @eigen_list_get(%EigenList* ", iter_ptr_str, ", i64 ", curr_idx_str, ")"]
    result is emit of line

    # Store in loop variable
    line is cat6 of ["  store double ", elem_str, ", double* ", var_alloc_str, "", ""]
    result is emit of line

    # Check if there's a condition
    if cond_idx > 0:
        # Generate condition check
        cond_result_reg is gen_expr of cond_idx
        cond_result_str is make_reg of cond_result_reg

        cond_cmp_reg is next_reg of 0
        cond_cmp_str is make_reg of cond_cmp_reg
        line is cat5 of ["  ", cond_cmp_str, " = fcmp one double ", cond_result_str, ", 0.0"]
        result is emit of line

        # Labels for condition branch
        add_lbl is next_label of 0
        skip_lbl is next_label of 0
        add_str is make_label of add_lbl
        skip_str is make_label of skip_lbl

        line is cat7 of ["  br i1 ", cond_cmp_str, ", label %", add_str, ", label %", skip_str, ""]
        result is emit of line
        result is emit of ""

        # Add block - generate expression and append
        line is cat3 of [add_str, ":", ""]
        result is emit of line

        expr_reg is gen_expr of expr_idx
        expr_str is make_reg of expr_reg

        # Convert result list to double for append
        result_double_reg is next_reg of 0
        result_double_str is make_reg of result_double_reg
        line is cat6 of ["  ", result_double_str, " = call double @eigen_list_to_double(%EigenList* ", result_list_str, ")", ""]
        result is emit of line

        line is cat6 of ["  call void @eigen_list_append_val(double ", result_double_str, ", double ", expr_str, ")", ""]
        result is emit of line

        line is cat3 of ["  br label %", skip_str, ""]
        result is emit of line
        result is emit of ""

        # Skip block - increment and continue
        line is cat3 of [skip_str, ":", ""]
        result is emit of line
    else:
        # No condition - always add
        expr_reg is gen_expr of expr_idx
        expr_str is make_reg of expr_reg

        # Convert result list to double for append
        result_double_reg is next_reg of 0
        result_double_str is make_reg of result_double_reg
        line is cat6 of ["  ", result_double_str, " = call double @eigen_list_to_double(%EigenList* ", result_list_str, ")", ""]
        result is emit of line

        line is cat6 of ["  call void @eigen_list_append_val(double ", result_double_str, ", double ", expr_str, ")", ""]
        result is emit of line

    # Increment index
    next_idx_reg is next_reg of 0
    next_idx_str is make_reg of next_idx_reg
    line is cat6 of ["  ", next_idx_str, " = add i64 ", curr_idx_str, ", 1", ""]
    result is emit of line
    line is cat6 of ["  store i64 ", next_idx_str, ", i64* ", idx_alloc_str, ""]
    result is emit of line

    # Jump back to condition
    line is cat3 of ["  br label %", cond_str, ""]
    result is emit of line
    result is emit of ""

    # End block
    line is cat3 of [end_str, ":", ""]
    result is emit of line

    # Return result list as double
    final_reg is next_reg of 0
    final_str is make_reg of final_reg
    line is cat6 of ["  ", final_str, " = call double @eigen_list_to_double(%EigenList* ", result_list_str, ")", ""]
    result is emit of line

    return final_reg

# Generate interrogative: what/who/why/how/when/where is expr
define gen_interrogative of node_idx as:
    arr_idx is node_idx + 1
    expr_idx is ast_left[arr_idx]
    interrog_type is ast_num_value[arr_idx]

    # Generate the target expression
    target_reg is gen_expr of expr_idx
    target_str is make_reg of target_reg

    # Determine which runtime function to call based on interrogative type
    func_name is ""
    if interrog_type = TT_WHAT:
        func_name is "eigen_what_is"
    if interrog_type = TT_WHO:
        func_name is "eigen_who_is"
    if interrog_type = TT_WHY:
        func_name is "eigen_why_is"
    if interrog_type = TT_HOW:
        func_name is "eigen_how_is"
    if interrog_type = TT_WHEN:
        func_name is "eigen_when_is"
    if interrog_type = TT_WHERE:
        func_name is "eigen_where_is"

    # Default to what_is if unknown
    is_empty is string_equals of [func_name, ""]
    if is_empty = 1:
        func_name is "eigen_what_is"

    # Generate call: %result = call double @eigen_X_is(double %target)
    reg is next_reg of 0
    reg_str is make_reg of reg
    line is cat7 of ["  ", reg_str, " = call double @", func_name, "(double ", target_str, ")"]
    result is emit of line

    return reg

# Generate slice: list[start:end] or string[start:end]
define gen_slice of node_idx as:
    arr_idx is node_idx + 1
    expr_idx is ast_left[arr_idx]
    start_idx is ast_right[arr_idx]
    end_idx is ast_third[arr_idx]

    # Generate the expression being sliced
    expr_reg is gen_expr of expr_idx
    expr_str is make_reg of expr_reg

    # Generate start and end indices
    start_reg is gen_expr of start_idx
    start_str is make_reg of start_reg
    end_reg is gen_expr of end_idx
    end_str is make_reg of end_reg

    # Call list slice (works for both lists and strings via runtime detection)
    # For now, use list slice - could add type detection later
    reg is next_reg of 0
    reg_str is make_reg of reg
    line is cat5 of ["  ", reg_str, " = call double @eigen_list_slice_val(double ", expr_str, ", "]
    line is cat5 of [line, "double ", start_str, ", double ", end_str]
    line is string_concat of [line, ")"]
    result is emit of line

    return reg

# Generate member access: object.member
# For module access, resolve the function name at compile time
define gen_member_access of node_idx as:
    arr_idx is node_idx + 1
    obj_idx is ast_left[arr_idx]
    member_idx is ast_str_index[arr_idx]

    # Get the object expression
    obj_arr_idx is obj_idx + 1
    obj_type is ast_types[obj_arr_idx]

    # If the object is an identifier (module name), create mangled function name
    if obj_type = AST_IDENTIFIER:
        module_name_idx is ast_str_index[obj_arr_idx]
        module_name is lexer_get_string of module_name_idx
        member_name is lexer_get_string of member_idx
        # Create mangled name: module_member
        mangled_name is string_concat of [module_name, "_"]
        mangled_name is string_concat of [mangled_name, member_name]
        # For now, return a reference that can be used in calls
        # Store the mangled name for later use
        result is emit of "  ; member access - module function reference"
        return 0

    # Otherwise, evaluate the object and access the member (for struct access)
    # This would need struct support - for now emit error
    result is emit of "  ; ERROR: member access on non-identifier not supported"
    return 0

# Main expression dispatch
define gen_expr of node_idx as:
    arr_idx is node_idx + 1
    node_type is ast_types[arr_idx]

    if node_type = AST_LITERAL:
        return gen_literal of node_idx

    if node_type = AST_IDENTIFIER:
        return gen_identifier of node_idx

    if node_type = AST_BINARY_OP:
        return gen_binary_op of node_idx

    if node_type = AST_UNARY_OP:
        return gen_unary_op of node_idx

    if node_type = AST_RELATION:
        return gen_relation of node_idx

    if node_type = AST_INDEX:
        return gen_index of node_idx

    if node_type = AST_SLICE:
        return gen_slice of node_idx

    if node_type = AST_MEMBER_ACCESS:
        return gen_member_access of node_idx

    if node_type = AST_LIST_LITERAL:
        return gen_list_literal of node_idx

    if node_type = AST_LIST_COMP:
        return gen_list_comp of node_idx

    if node_type = AST_STRUCT_LITERAL:
        # Struct literal is represented as a list of field values
        return gen_list_literal of node_idx

    if node_type = AST_INTERROGATIVE:
        return gen_interrogative of node_idx

    # Default: return 0
    return 0

# ============================================================================
# Statement Code Generation
# ============================================================================

define gen_assignment of node_idx as:
    arr_idx is node_idx + 1
    name_idx is ast_str_index[arr_idx]
    expr_idx is ast_left[arr_idx]

    # Generate expression value
    expr_reg is gen_expr of expr_idx
    expr_str is make_reg of expr_reg

    # Check if variable exists (using numeric index for comparison)
    var_reg is lookup_var of name_idx

    if var_reg < 0:
        # New variable - allocate
        var_reg is next_reg of 0
        var_str is make_reg of var_reg
        line is cat4 of ["  ", var_str, " = alloca double", ""]
        result is emit of line
        result is add_var of [name_idx, var_reg]

    var_str is make_reg of var_reg

    # Store value
    line is cat6 of ["  store double ", expr_str, ", double* ", var_str, "", ""]
    result is emit of line

    return 0

# Generate indexed assignment: list[index] is value
define gen_indexed_assignment of node_idx as:
    arr_idx is node_idx + 1
    list_idx is ast_left[arr_idx]
    index_idx is ast_right[arr_idx]
    value_idx is ast_third[arr_idx]

    # Generate list expression
    list_reg is gen_expr of list_idx
    list_str is make_reg of list_reg

    # Generate index expression
    index_reg is gen_expr of index_idx
    index_str is make_reg of index_reg

    # Generate value expression
    value_reg is gen_expr of value_idx
    value_str is make_reg of value_reg

    # Convert index to i64
    idx_i64_reg is next_reg of 0
    idx_i64_str is make_reg of idx_i64_reg
    line is cat6 of ["  ", idx_i64_str, " = fptosi double ", index_str, " to i64", ""]
    result is emit of line

    # Convert list handle (double) to list pointer
    list_ptr_reg is next_reg of 0
    list_ptr_str is make_reg of list_ptr_reg
    line is cat6 of ["  ", list_ptr_str, " = call %EigenList* @eigen_double_to_list(double ", list_str, ")", ""]
    result is emit of line

    # Set element in list
    line is cat7 of ["  call void @eigen_list_set(%EigenList* ", list_ptr_str, ", i64 ", idx_i64_str, ", double ", value_str, ")"]
    result is emit of line

    return 0

define gen_return of node_idx as:
    arr_idx is node_idx + 1
    expr_idx is ast_left[arr_idx]
    ret_reg is gen_expr of expr_idx
    ret_str is make_reg of ret_reg

    line is cat4 of ["  ret double ", ret_str, "", ""]
    result is emit of line

    return 0

define gen_conditional of node_idx as:
    arr_idx is node_idx + 1
    cond_idx is ast_left[arr_idx]
    if_start is ast_num_value[arr_idx]
    if_end is ast_right[arr_idx]
    else_info is ast_third[arr_idx]
    else_start is else_info / 100000
    else_end is else_info % 100000

    # Generate condition
    cond_reg is gen_expr of cond_idx
    cond_str is make_reg of cond_reg

    # Convert to i1
    cmp_reg is next_reg of 0
    cmp_str is make_reg of cmp_reg
    line is cat5 of ["  ", cmp_str, " = fcmp one double ", cond_str, ", 0.0"]
    result is emit of line

    # Labels
    then_lbl is next_label of 0
    else_lbl is next_label of 0
    end_lbl is next_label of 0

    then_str is make_label of then_lbl
    else_str is make_label of else_lbl
    end_str is make_label of end_lbl

    # Branch
    line is cat7 of ["  br i1 ", cmp_str, ", label %", then_str, ", label %", else_str, ""]
    result is emit of line
    result is emit of ""

    # Then block
    line is cat3 of [then_str, ":", ""]
    result is emit of line
    result is gen_block of [if_start, if_end]
    line is cat3 of ["  br label %", end_str, ""]
    result is emit of line
    result is emit of ""

    # Else block
    line is cat3 of [else_str, ":", ""]
    result is emit of line
    if else_start != else_end:
        result is gen_block of [else_start, else_end]
    line is cat3 of ["  br label %", end_str, ""]
    result is emit of line
    result is emit of ""

    # End block
    line is cat3 of [end_str, ":", ""]
    result is emit of line

    return 0

define gen_loop of node_idx as:
    arr_idx is node_idx + 1
    cond_idx is ast_left[arr_idx]
    body_start is ast_num_value[arr_idx]
    body_end is ast_right[arr_idx]

    # Labels
    cond_lbl is next_label of 0
    body_lbl is next_label of 0
    end_lbl is next_label of 0

    cond_str is make_label of cond_lbl
    body_str is make_label of body_lbl
    end_str is make_label of end_lbl

    # Save outer loop's labels and set current
    outer_exit_label is current_loop_exit_label
    outer_cond_label is current_loop_cond_label
    current_loop_exit_label is end_lbl
    current_loop_cond_label is cond_lbl

    # Jump to condition
    line is cat3 of ["  br label %", cond_str, ""]
    result is emit of line
    result is emit of ""

    # Condition block
    line is cat3 of [cond_str, ":", ""]
    result is emit of line

    cond_reg is gen_expr of cond_idx
    cond_reg_str is make_reg of cond_reg

    cmp_reg is next_reg of 0
    cmp_str is make_reg of cmp_reg
    line is cat5 of ["  ", cmp_str, " = fcmp one double ", cond_reg_str, ", 0.0"]
    result is emit of line

    line is cat7 of ["  br i1 ", cmp_str, ", label %", body_str, ", label %", end_str, ""]
    result is emit of line
    result is emit of ""

    # Body block
    line is cat3 of [body_str, ":", ""]
    result is emit of line
    result is gen_block of [body_start, body_end]
    line is cat3 of ["  br label %", cond_str, ""]
    result is emit of line
    result is emit of ""

    # End block
    line is cat3 of [end_str, ":", ""]
    result is emit of line

    # Restore outer loop's labels
    current_loop_exit_label is outer_exit_label
    current_loop_cond_label is outer_cond_label

    return 0

define gen_function_def of node_idx as:
    # Reset variable scope and register counter for this function
    # Each function gets its own fresh variable environment and SSA registers
    var_count is 0
    reg_counter is 0

    arr_idx is node_idx + 1
    name_idx is ast_str_index[arr_idx]
    param_count is ast_left[arr_idx]
    children_start is ast_children_start[arr_idx]
    body_start is ast_right[arr_idx]
    body_end is ast_children_end[arr_idx]

    # Get function name string
    func_name is lexer_get_string of name_idx

    result is emit of ""

    # Build function signature with parameters
    if param_count = 0:
        line is cat3 of ["define double @", func_name, "() {"]
        result is emit of line
    else:
        # Build complete parameter list string
        param_str is ""
        i is 0
        loop while i < param_count:
            param_arr_idx is children_start + i + 1
            param_name_idx is ast_children[param_arr_idx]
            param_name is lexer_get_string of param_name_idx

            if i = 0:
                param_str is cat3 of ["double %param_", param_name, ""]
            else:
                param_str is cat5 of [param_str, ", double %param_", param_name, "", ""]
            i is i + 1

        # Emit complete signature
        line is cat5 of ["define double @", func_name, "(", param_str, ") {"]
        result is emit of line

    result is emit of "entry:"

    # Create alloca for each parameter and store incoming value
    i is 0
    loop while i < param_count:
        param_arr_idx is children_start + i + 1
        param_name_idx is ast_children[param_arr_idx]
        param_name is lexer_get_string of param_name_idx

        # Allocate stack space for parameter
        alloc_reg is next_reg of 0
        alloc_str is make_reg of alloc_reg
        line is cat4 of ["  ", alloc_str, " = alloca double", ""]
        result is emit of line

        # Store incoming parameter value
        line is cat6 of ["  store double %param_", param_name, ", double* ", alloc_str, "", ""]
        result is emit of line

        # Register the parameter variable for lookup
        result is add_var of [param_name_idx, alloc_reg]

        i is i + 1

    # Generate body (statements from body_start to body_end)
    result is gen_block of [body_start, body_end]

    result is emit of "  ret double 0.0"
    result is emit of "}"
    result is emit of ""

    return 0

define gen_block of [start, end] as:
    s is start
    e is end
    i is s
    loop while i < e:
        # ast_children also has dummy at index 0
        arr_i is i + 1
        stmt_idx is ast_children[arr_i]
        result is gen_stmt of stmt_idx
        i is i + 1
    return 0

# Check if a statement index is within a function body (child of AST_FUNCTION_DEF)
# Returns 1 if it's inside a function body, 0 otherwise
define is_in_function_body of [stmt_idx, prog_start, prog_end] as:
    # Iterate through program statements looking for function definitions
    j is prog_start
    loop while j < prog_end:
        arr_j is j + 1
        other_idx is ast_children[arr_j]
        other_arr_idx is other_idx + 1
        other_type is ast_types[other_arr_idx]
        if other_type = AST_FUNCTION_DEF:
            # Check if stmt_idx is in this function's body range
            func_children_start is ast_children_start[other_arr_idx]
            func_children_end is ast_children_end[other_arr_idx]
            # Check if stmt_idx is in ast_children[func_children_start..func_children_end)
            k is func_children_start
            loop while k < func_children_end:
                arr_k is k + 1
                child_idx is ast_children[arr_k]
                if child_idx = stmt_idx:
                    return 1
                k is k + 1
        j is j + 1
    return 0

# Generate block but skip function definitions (for main's global code)
define gen_block_skip_functions of [start, end] as:
    s is start
    e is end
    i is s
    loop while i < e:
        arr_i is i + 1
        stmt_idx is ast_children[arr_i]
        stmt_arr_idx is stmt_idx + 1
        stmt_type is ast_types[stmt_arr_idx]
        # Skip function definitions - they'll be generated after main
        if stmt_type != AST_FUNCTION_DEF:
            # Also skip statements that are children of function definitions
            # (they get added to ast_children but belong to the function, not program)
            in_func is is_in_function_body of [stmt_idx, s, e]
            if in_func = 0:
                result is gen_stmt of stmt_idx
        i is i + 1
    return 0

# Generate block but only process function definitions (after main)
define gen_block_functions_only of [start, end] as:
    s is start
    e is end
    i is s
    loop while i < e:
        arr_i is i + 1
        stmt_idx is ast_children[arr_i]
        stmt_arr_idx is stmt_idx + 1
        stmt_type is ast_types[stmt_arr_idx]
        # Only generate function definitions
        if stmt_type = AST_FUNCTION_DEF:
            result is gen_function_def of stmt_idx
        i is i + 1
    return 0

define gen_stmt of node_idx as:
    arr_idx is node_idx + 1
    node_type is ast_types[arr_idx]

    if node_type = AST_ASSIGNMENT:
        return gen_assignment of node_idx

    if node_type = AST_INDEXED_ASSIGNMENT:
        return gen_indexed_assignment of node_idx

    if node_type = AST_CONDITIONAL:
        return gen_conditional of node_idx

    if node_type = AST_LOOP:
        return gen_loop of node_idx

    if node_type = AST_RETURN:
        return gen_return of node_idx

    if node_type = AST_BREAK:
        # Jump to current loop's exit label
        if current_loop_exit_label > 0:
            exit_str is make_label of current_loop_exit_label
            line is cat3 of ["  br label %", exit_str, ""]
            result is emit of line
            # Need a new block after break since br is a terminator
            after_lbl is next_label of 0
            after_str is make_label of after_lbl
            line is cat3 of [after_str, ":", ""]
            result is emit of line
        else:
            result is emit of "  ; ERROR: break outside loop"
        return 0

    if node_type = AST_CONTINUE:
        # Jump to current loop's condition label
        if current_loop_cond_label > 0:
            cond_str is make_label of current_loop_cond_label
            line is cat3 of ["  br label %", cond_str, ""]
            result is emit of line
            # Need a new block after continue since br is a terminator
            after_lbl is next_label of 0
            after_str is make_label of after_lbl
            line is cat3 of [after_str, ":", ""]
            result is emit of line
        else:
            result is emit of "  ; ERROR: continue outside loop"
        return 0

    if node_type = AST_FUNCTION_DEF:
        return gen_function_def of node_idx

    if node_type = AST_STRUCT_DEF:
        # Record struct definition for field lookups
        arr_idx is node_idx + 1
        struct_name_idx is ast_str_index[arr_idx]
        children_start is ast_children_start[arr_idx]
        children_end is ast_children_end[arr_idx]
        field_count is children_end - children_start

        # Add struct to table
        result is add_struct of [struct_name_idx, field_count]

        # Add field names
        i is children_start
        loop while i < children_end:
            field_arr_i is i + 1
            field_node is ast_children[field_arr_i]
            field_node_arr is field_node + 1
            field_name_idx is ast_str_index[field_node_arr]
            result is add_struct_field of field_name_idx
            i is i + 1

        struct_name is lexer_get_string of struct_name_idx
        line is cat4 of ["  ; struct ", struct_name, " defined with fields", ""]
        result is emit of line
        return 0

    if node_type = AST_IMPORT:
        return 0

    if node_type = AST_IMPORT_FROM:
        return 0

    # Expression statement
    result is gen_expr of node_idx
    return 0

# ============================================================================
# Main Entry Point
# ============================================================================

define generate of root_node as:
    reg_counter is 0
    label_counter is 0
    output_count is 0
    var_count is 0

    result is emit_header of 0
    result is emit_runtime_decls of 0
    result is emit_string_constants of 0

    result is emit of "; Main function"
    result is emit of "define i32 @main(i32 %argc, i8** %argv) {"
    result is emit of "entry:"
    result is emit of "  ; Initialize CLI args for get_argc/get_arg builtins"
    result is emit of "  call void @eigen_init_args(i32 %argc, i8** %argv)"
    result is emit of ""

    in_main is 1

    # First pass: generate only non-function statements (global code for main)
    arr_idx is root_node + 1
    start is ast_children_start[arr_idx]
    end is ast_children_end[arr_idx]
    result is gen_block_skip_functions of [start, end]

    result is emit of "  ret i32 0"
    result is emit of "}"

    in_main is 0

    # Second pass: generate all function definitions (after main)
    result is gen_block_functions_only of [start, end]

    return output_count

define print_ir as:
    # IR is now printed directly in emit(), no buffering needed
    return output_count

# Initialize codegen state
define init_codegen as:
    reg_counter is 0
    label_counter is 0
    string_counter is 0
    in_main is 0
    output_lines is []
    output_count is 0
    var_count is 0
    struct_count is 0
    struct_field_total is 0
    return 0
